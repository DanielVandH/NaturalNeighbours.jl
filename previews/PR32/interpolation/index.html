<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interpolation · NaturalNeighbours.jl</title><meta name="title" content="Interpolation · NaturalNeighbours.jl"/><meta property="og:title" content="Interpolation · NaturalNeighbours.jl"/><meta property="twitter:title" content="Interpolation · NaturalNeighbours.jl"/><meta name="description" content="Documentation for NaturalNeighbours.jl."/><meta property="og:description" content="Documentation for NaturalNeighbours.jl."/><meta property="twitter:description" content="Documentation for NaturalNeighbours.jl."/><meta property="og:url" content="https://DanielVandH.github.io/NaturalNeighbours.jl/interpolation/"/><meta property="twitter:url" content="https://DanielVandH.github.io/NaturalNeighbours.jl/interpolation/"/><link rel="canonical" href="https://DanielVandH.github.io/NaturalNeighbours.jl/interpolation/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NaturalNeighbours.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Interpolation</a></li><li><a class="tocitem" href="../differentiation/">Differentiation</a></li><li><a class="tocitem" href="../swiss/">Switzerland Elevation Data</a></li></ul></li><li><a class="tocitem" href="../compare/">Comparison of Interpolation Methods</a></li><li><span class="tocitem">Mathematical Details</span><ul><li><a class="tocitem" href="../interpolation_math/">Interpolation Details</a></li><li><a class="tocitem" href="../differentiation_math/">Differentiation Details</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Interpolation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interpolation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/DanielVandH/NaturalNeighbours.jl/blob/main/docs/src/interpolation.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Interpolation-Example"><a class="docs-heading-anchor" href="#Interpolation-Example">Interpolation Example</a><a id="Interpolation-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation-Example" title="Permalink"></a></h1><p>Let us give an example of how interpolation can be performed. We consider the function</p><p class="math-container">\[f(x, y) = \frac19\left[\tanh\left(9y-9x\right) + 1\right].\]</p><p>First, let us generate some data.</p><pre><code class="language-julia hljs">using NaturalNeighbours 
using CairoMakie 
using StableRNGs 

f = (x, y) -&gt; (1 / 9) * (tanh(9 * y - 9 * x) + 1)

rng = StableRNG(123)
x = rand(rng, 100)
y = rand(rng, 100)
z = f.(x, y)</code></pre><p>We can now construct our interpolant. To use the Sibson-1 interpolant, we need to have gradient information, so we specify <code>derivatives=true</code> to make sure these get generated at the data sites.</p><pre><code class="language-julia hljs">itp = interpolate(x, y, z; derivatives=true)</code></pre><p>This <code>itp</code> is now callable. Let&#39;s generate a grid to evaluate <code>itp</code> at.</p><pre><code class="language-julia hljs">xg = LinRange(0, 1, 100)
yg = LinRange(0, 1, 100)
_x = vec([x for x in xg, _ in yg])
_y = vec([y for _ in xg, y in yg])</code></pre><p>We use vectors for this evaluation rather than evaluating like, say, <code>[itp(x, y) for x in xg, y in yg]</code>, since <code>itp</code>&#39;s evaluation will use multithreading if we give it vectors. Consider the following times (including the time to make the vectors in the vector case):</p><pre><code class="language-julia hljs">using BenchmarkTools
function testf1(itp, xg, yg, parallel)
    _x = vec([x for x in xg, _ in yg])
    _y = vec([y for _ in xg, y in yg])
    return itp(_x, _y; parallel=parallel)
end
testf2(itp, xg, yg) = [itp(x, y) for x in xg, y in yg]
b1 = @benchmark $testf1($itp, $xg, $yg, $true)
b2 = @benchmark $testf2($itp, $xg, $yg)
b3 = @benchmark $testf1($itp, $xg, $yg, $false)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; b1
BenchmarkTools.Trial: 2310 samples with 1 evaluation.
 Range (min … max):  1.333 ms … 165.550 ms  ┊ GC (min … max): 0.00% … 98.28%
 Time  (median):     1.781 ms               ┊ GC (median):    0.00%
 Time  (mean ± σ):   2.155 ms ±   3.446 ms  ┊ GC (mean ± σ):  3.27% ±  2.04%

        ▄▆█▄▁
  ▂▂▄▃▅▆█████▆▅▃▃▂▂▂▂▂▂▂▃▂▂▃▃▃▃▃▃▄▃▄▄▄▄▅▅▄▄▄▄▄▃▃▃▄▃▂▂▂▂▁▂▁▁▁▁ ▃
  1.33 ms         Histogram: frequency by time        3.33 ms &lt;

 Memory estimate: 254.33 KiB, allocs estimate: 146.

julia&gt; b2
BenchmarkTools.Trial: 257 samples with 1 evaluation.
 Range (min … max):  14.790 ms … 27.120 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     18.136 ms              ┊ GC (median):    0.00%
 Time  (mean ± σ):   19.531 ms ±  4.177 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%

   ▅█
  ▆██▄▄▄▄▂▅▁▁▄▃▄▅▃▃▃▃▁▃▃▁▃▄▃▃▃▂▂▄▂▃▃▂▄▂▄▄▃▂▄▄▃▃▄▃▄▄▃▄▃▃▄▄▂▄▅▄ ▃
  14.8 ms         Histogram: frequency by time        26.7 ms &lt;

 Memory estimate: 78.17 KiB, allocs estimate: 2.

julia&gt; b3
BenchmarkTools.Trial: 267 samples with 1 evaluation.
 Range (min … max):  14.986 ms … 27.264 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     17.354 ms              ┊ GC (median):    0.00%
 Time  (mean ± σ):   18.710 ms ±  3.750 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%

   ▄█
  ▄██▇▄▃▃▄▃▃▃▃▃▃▃▄▄▂▃▃▃▃▃▃▃▃▃▃▃▃▂▁▃▃▃▃▃▃▃▃▃▂▃▃▂▃▃▂▂▁▂▃▃▂▃▂▃▄▃ ▃
  15 ms           Histogram: frequency by time        26.7 ms &lt;

 Memory estimate: 234.67 KiB, allocs estimate: 10.</code></pre><p>See that <code>itp(_x, _y)</code> took about 1.3 ms, while the latter two approaches both take around  15 ms. Pretty impressive given that we are evaluating <span>$100^2$</span> points - this is a big advantage of local interpolation making parallel evaluation so cheap and simple. This effect can be made even more clear if we use more points:</p><pre><code class="language-julia hljs">xg = LinRange(0, 1, 1000)
yg = LinRange(0, 1, 1000)
b1 = @benchmark $testf1($itp, $xg, $yg, $true)
b2 = @benchmark $testf2($itp, $xg, $yg)
b3 = @benchmark $testf1($itp, $xg, $yg, $false)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; b1
BenchmarkTools.Trial: 27 samples with 1 evaluation.
 Range (min … max):  132.766 ms … 354.348 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     144.794 ms               ┊ GC (median):    0.00%
 Time  (mean ± σ):   188.429 ms ±  79.396 ms  ┊ GC (mean ± σ):  0.37% ± 2.38%

  ▁█▃▁
  ████▄▄▄▁▁▁▁▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄▁▁▁▁▄▄▁▁▁▁▁▁▁▁▄▁▁▁▁▁▁▁▄▇ ▁
  133 ms           Histogram: frequency by time          354 ms &lt;

 Memory estimate: 22.91 MiB, allocs estimate: 157.

julia&gt; b2
BenchmarkTools.Trial: 2 samples with 1 evaluation.
 Range (min … max):  2.564 s …    2.794 s  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     2.679 s               ┊ GC (median):    0.00%
 Time  (mean ± σ):   2.679 s ± 162.574 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%

  █                                                        █
  █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁
  2.56 s         Histogram: frequency by time         2.79 s &lt;

 Memory estimate: 7.63 MiB, allocs estimate: 2.

julia&gt; b3
BenchmarkTools.Trial: 2 samples with 1 evaluation.
 Range (min … max):  2.557 s …   2.624 s  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     2.590 s              ┊ GC (median):    0.00%
 Time  (mean ± σ):   2.590 s ± 46.978 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%

  █                                                       █
  █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁
  2.56 s         Histogram: frequency by time        2.62 s &lt;

 Memory estimate: 22.89 MiB, allocs estimate: 10.</code></pre><p>Now let&#39;s continue with the example. We compare Sibson-0 to Sibson-1 (going back to the original definitions of <code>xg</code> and <code>yg</code> with <span>$100^2$</span> points):</p><pre><code class="language-julia hljs">sib_vals = itp(_x, _y)
sib1_vals = itp(_x, _y; method=Sibson(1))</code></pre><p>Now we can plot.</p><pre><code class="language-julia hljs">function plot_itp(fig, x, y, vals, title, i, show_data_sites, itp, xd=nothing, yd=nothing, show_3d=true, levels=-0.1:0.05:0.3)
    ax = Axis(fig[1, i], xlabel=&quot;x&quot;, ylabel=&quot;y&quot;, width=600, height=600, title=title, titlealign=:left)
    c = contourf!(ax, x, y, vals, color=vals, colormap=:viridis, levels=levels, extendhigh=:auto)
    show_data_sites &amp;&amp; scatter!(ax, xd, yd, color=:red, markersize=9)
    tri = itp.triangulation
    ch_idx = get_convex_hull_vertices(tri)
    lines!(ax, [get_point(tri, i) for i in ch_idx], color=:white, linewidth=4)
    if show_3d
        ax = Axis3(fig[2, i], xlabel=&quot;x&quot;, ylabel=&quot;y&quot;, zlabel=L&quot;z&quot;, width=600, height=600, title=&quot; &quot;, titlealign=:left, azimuth=0.49)
        surface!(ax, x, y, vals, color=vals, colormap=:viridis, colorrange=(-0.1, 0.3))
        zlims!(ax, 0, 0.25)
    end
    return c
end</code></pre><figure>
    <img src='../figures/sibson_vs_sibson1.png', alt'Sibson and Sibson-1 Interpolation'><br>
</figure><p>The red points in (c) show the data used for interpolating. The results are pretty similar, although Sibson-1 is more bumpy in the zero region of the function. Sibson-1 is smooth wave on the rising front of the function.</p><p>Note that we are extrapolating in some parts of this function, where extrapolation refers to evaluating outside of the convex hull of the data sites. This convex hull is shown in white above. If we wanted to avoid extrapolating entirely, you can use <code>project=false</code> which replaces any extrapolated values with <code>Inf</code>.</p><pre><code class="language-julia hljs">sib_vals = itp(_x, _y, project=false)
sib1_vals = itp(_x, _y; method=Sibson(1), project=false)
fig = Figure(fontsize=36)
plot_itp(fig, _x, _y, sib_vals, &quot;(a): Sibson&quot;, 1, false, itp, x, y)
plot_itp(fig, _x, _y, sib1_vals, &quot;(b): Sibson-1&quot;, 2, false, itp, x, y)
plot_itp(fig, _x, _y, f.(_x, _y), &quot;(c): Exact&quot;, 3, true, itp, x, y)
resize_to_layout!(fig)
fig</code></pre><figure>
    <img src='../figures/sibson_vs_sibson1_project_false.png', alt'Sibson and Sibson-1 Interpolation without Extrapolation'><br>
</figure><p>To get a better comparison of the two interpolants, lets plot the errors at each point, including extrapolation.</p><pre><code class="language-julia hljs">sib_vals = itp(_x, _y)
sib1_vals = itp(_x, _y; method=Sibson(1))
sib_errs = @. 100abs(sib_vals - f(_x, _y))
sib1_errs = @. 100abs(sib1_vals - f(_x, _y))

fig = Figure(fontsize=36)
plot_itp(fig, _x, _y, sib_errs, &quot;(a): Sibson&quot;, 1, true, itp, x, y, false, 0:0.5:3)
c = plot_itp(fig, _x, _y, sib1_errs, &quot;(b): Sibson-1&quot;, 2, true, itp, x, y, false, 0:0.5:3)
Colorbar(fig[1, 3], c)
resize_to_layout!(fig)
fig</code></pre><figure>
    <img src='../figures/sibson_vs_sibson1_errors.png', alt'Sibson and Sibson-1 Interpolation Errors'><br>
</figure><p>We see that the Sibson-1 interpolant has less error overall. To summarise these errors into a single scalar, we can use the relative root mean square error, defined by </p><p class="math-container">\[\varepsilon_{\text{rrmse}}(\boldsymbol y, \hat{\boldsymbol y}) = 100\sqrt{\frac{\sum_i (y_i - \hat y_i)^2}{\sum_i \hat y_i^2}}.\]</p><pre><code class="language-julia-repl hljs">julia&gt; esib0 = 100sqrt(sum((sib_vals .- f.(_x, _y)).^2) / sum(sib_vals.^2))
8.272516151708604

julia&gt; esib1 = 100sqrt(sum((sib1_vals .- f.(_x, _y)).^2) / sum(sib_vals.^2))
6.974149853003652</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../differentiation/">Differentiation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 13 May 2024 20:54">Monday 13 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
