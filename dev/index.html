<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · NaturalNeighbours.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/NaturalNeighbours.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>NaturalNeighbours.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="interpolation/">Interpolation</a></li><li><a class="tocitem" href="differentiation/">Differentiaton</a></li><li><a class="tocitem" href="swiss/">Switzerland Elevation Data</a></li></ul></li><li><a class="tocitem" href="compare/">Comparison of Interpolation Methods</a></li><li><span class="tocitem">Mathematical Details</span><ul><li><a class="tocitem" href="interpolation_math/">Interpolation Details</a></li><li><a class="tocitem" href="differentiation_math/">Differentiation Details</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/NaturalNeighbours.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="NaturalNeighbours"><a class="docs-heading-anchor" href="#NaturalNeighbours">NaturalNeighbours</a><a id="NaturalNeighbours-1"></a><a class="docs-heading-anchor-permalink" href="#NaturalNeighbours" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/DanielVandH/NaturalNeighbours.jl">NaturalNeighbours</a>.</p><p>This is a package for working with natural neighbours of planar point sets, enabling scattered data (or spatial) interpolation via <a href="https://en.wikipedia.org/wiki/Natural_neighbor_interpolation">natural neighbour interpolation</a>, as well as derivative generation. We use <a href="https://github.com/DanielVandH/DelaunayTriangulation.jl">DelaunayTriangulation.jl</a> to define the spatial information. Much of the work in this package is based on <a href="https://kluedo.ub.rptu.de/frontdoor/deliver/index/docId/2104/file/diss.bobach.natural.neighbor.20090615.pdf">this great thesis</a>.</p><p>Please see the sections in the sidebar for some more discussion. The relevant docstrings for this package are shown below.</p><article class="docstring"><header><a class="docstring-binding" id="NaturalNeighbours.interpolate" href="#NaturalNeighbours.interpolate"><code>NaturalNeighbours.interpolate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interpolate(tri::Triangulation, z; gradient=nothing, hessian=nothing, derivatives=false, kwargs...)
interpolate(points, z; gradient=nothing, hessian=nothing, derivatives=false, kwargs...)
interpolate(x::AbstractVector, y::AbstractVector, z; gradient=nothing, hessian=nothing, derivatives=false, kwargs...)</code></pre><p>Construct an interpolant over the data <code>z</code> at the sites defined by the triangulation <code>tri</code> (or <code>points</code>, or <code>(x, y)</code>). See the Output  section for a description of how to use the interpolant <code>itp</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>gradient=nothing</code>: The gradients at the corresponding data sites of <code>z</code>. Will be generated if <code>isnothing(gradient)</code> and <code>derivatives==true</code>.</li><li><code>hessian=nothing</code>: The hessians at the corresponding data sites of <code>z</code>. Will be generated if <code>isnothing(hessian)</code> and <code>derivatives==true</code>.</li><li><code>derivatives=false</code>: Whether to generate derivatives at the data sites of <code>z</code>. See also <a href="#NaturalNeighbours.generate_derivatives"><code>generate_derivatives</code></a>.</li><li><code>kwargs...</code>: Keyword arguments passed to <a href="#NaturalNeighbours.generate_derivatives"><code>generate_derivatives</code></a>.</li></ul><p><strong>Output</strong></p><p>The returned value is a <code>NaturalNeighboursInterpolant</code> struct. This struct is callable, with the following methods defined:</p><pre><code class="nohighlight hljs">(itp::NaturalNeighboursInterpolant)(x, y, id::Integer=1; parallel=false, method=Sibson(), project = true, kwargs...)
(itp::NaturalNeighboursInterpolant)(vals::AbstractVector, x::AbstractVector, y::AbstractVector; parallel=true, method=Sibson(), project = true, kwargs...)
(itp::NaturalNeighboursInterpolant)(x::AbstractVector, y::AbstractVector; parallel=true, method=Sibson(), project = true, kwargs...)</code></pre><ol><li>The first method is for scalars, with <code>id</code> referring to a thread id. </li><li>This method is an in-place method for vectors, storing <code>itp(x[i], y[i])</code> into <code>vals[i]</code>. </li><li>This method is similar to (2), but <code>vals</code> is constructed and returned. </li></ol><p>In each method, <code>method</code> defines the method used for evaluating the interpolant, which is some <a href="#NaturalNeighbours.AbstractInterpolator"><code>AbstractInterpolator</code></a>. For the first  method, <code>parallel</code> is ignored, but for the latter two methods it defines whether to use multithreading or not for evaluating the interpolant at  all the points. The <code>kwargs...</code> argument is passed into <code>add_point!</code> from DelaunayTriangulation.jl, e.g. you could pass some <code>rng</code>. Lastly,  the <code>project</code> argument determines whether extrapolation is performed by projecting any exterior points onto the boundary of the convex hull  of the data sites and performing two-point interpolation, or to simply replaced any extrapolated values with <code>Inf</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Until we implement ghost point extrapolation, behaviour near the convex hull of your data sites may in some cases be undesirable, despite the extrapolation method we describe above, even for points that are inside the convex hull. If you want to control this  behaviour so that you discard any points that are very close to the convex hull, see <code>identify_exterior_points</code> and the <code>tol</code>  keyword argument.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/NaturalNeighbours.jl/blob/badc110ac565b2ce7ee2e61d8d4944e30b156378/src/interpolation/interpolate.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaturalNeighbours.differentiate" href="#NaturalNeighbours.differentiate"><code>NaturalNeighbours.differentiate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">differentiate(itp::NaturalNeighboursInterpolant, order)</code></pre><p>Differentiate a given interpolant <code>itp</code> up to degree <code>order</code> (1 or 2). The returned object is a  <code>NaturalNeighboursDifferentiator</code> struct, which is callable. </p><p>For calling the resulting struct, we define the following methods:</p><pre><code class="nohighlight hljs">(∂::NaturalNeighboursDifferentiator)(x, y, zᵢ, nc, id::Integer=1; parallel=false, method=default_diff_method(∂), kwargs...)
(∂::NaturalNeighboursDifferentiator)(x, y, id::Integer=1; parallel=false, method=default_diff_method(∂), interpolant_method=Sibson(), rng=Random.default_rng(), project = true, kwargs...)
(∂::NaturalNeighboursDifferentiator)(vals::AbstractVector, x::AbstractVector, y::AbstractVector; parallel=true, method=default_diff_method(∂), interpolant_method=Sibson(), kwargs...)
(∂::NaturalNeighboursDifferentiator{I, O})(x::AbstractVector, y::AbstractVector; parallel=true, method=default_diff_method(∂), interpolant_method=Sibson(), kwargs...) where {I, O}</code></pre><ol><li>This method is useful if you already have an estimate for the function value, <code>zᵢ</code>, at the data site, <code>(x, y)</code>, provided you also provide the <code>NaturalCoordinates</code> <code>nc</code>. <code>id</code> is the thread id.</li><li>This method is for scalars, with <code>id</code> referring to a thread id.</li><li>This method is an in-place method for vectors, storing <code>∂(x[i], y[i], 1)</code> into <code>vals[i]</code>.</li><li>This method is similar to (3), but <code>vals</code> is constructed and returned.</li></ol><p>The available keyword arguments are:</p><ul><li><code>parallel=true</code>: Whether to use multithreading. Ignored for the first two methods. </li><li><code>method=default_diff_method(∂)</code>: Default method for evaluating the interpolant. <code>default_diff_method(∂)</code> returns <code>Direct()</code>. The method must be a <a href="#NaturalNeighbours.AbstractDifferentiator"><code>AbstractDifferentiator</code></a>.</li><li><code>interpolant_method=Sibson()</code>: The method used for evaluating the interpolant to estimate <code>zᵢ</code> for the latter three methods. See <a href="#NaturalNeighbours.AbstractInterpolator"><code>AbstractInterpolator</code></a> for the avaiable methods.</li><li><code>rng=Random.default_rng()</code>: The random number generator used for estimating <code>zᵢ</code> for the latter three methods, or for constructing the natural coordinates.</li><li><code>project=false</code>: Whether to project any extrapolated points onto the boundary of the convex hull of the data sites and perform two-point interpolation, or to simply replace any extrapolated values with <code>Inf</code>, when evaluating the interpolant in the latter three methods.</li><li><code>use_cubic_terms=true</code>: If estimating second order derivatives, whether to use cubic terms. Only relevant for <code>method == Direct()</code>.</li><li><code>alpha=0.1</code>: If estimating second order derivatives, the weighting parameter used for estimating the second order derivatives. Only relevant for <code>method == Iterative()</code>.</li><li><code>use_sibson_weight=true</code>: Whether to weight the residuals in the associated least squares problems by the associated Sibson coordinates. Only relevant for <code>method == Iterative()</code> if <code>order == 2</code>.</li></ul><p>The outputs are:</p><ul><li><code>order == 1</code>: The scalar methods return a <code>Tuple</code> of the form <code>(∂x, ∂y)</code>, while the vector methods return a vector of <code>Tuple</code>s of the form <code>(∂x, ∂y)</code>.</li><li><code>order == 2</code>: The scalar methods return a <code>(∇, ℋ)</code>, where <code>∇</code> is a <code>Tuple</code> of the form <code>(∂x, ∂y)</code> and <code>ℋ</code> is a <code>Tuple</code> of the form <code>(∂xx, ∂yy, ∂xy)</code>. The vector methods return a vector of <code>(∇, ℋ)</code>s.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Until we implement ghost point extrapolation, behaviour near the convex hull of your data sites may in some cases be undesirable, despite the extrapolation method we describe above, even for points that are inside the convex hull. If you want to control this  behaviour so that you discard any points that are very close to the convex hull, see <code>identify_exterior_points</code> and the <code>tol</code>  keyword argument.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/NaturalNeighbours.jl/blob/badc110ac565b2ce7ee2e61d8d4944e30b156378/src/differentiation/differentiate.jl#L1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaturalNeighbours.generate_gradients" href="#NaturalNeighbours.generate_gradients"><code>NaturalNeighbours.generate_gradients</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_gradients(
    tri,
    z,
    derivative_caches=[DerivativeCache(tri) for _ in 1:Base.Threads.nthreads()],
    neighbour_caches=[NaturalNeighboursCache(tri) for _ in 1:Base.Threads.nthreads()];
    parallel=true
)</code></pre><p>Generate gradients at the data sites defined by the triangulation <code>tri</code> with associated function values <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri</code>: A <code>Triangulation</code> object.</li><li><code>z</code>: A vector of function values at the data sites.</li><li><code>derivative_caches=[DerivativeCache(tri) for _ in 1:Base.Threads.nthreads()]</code>: A vector of <code>DerivativeCache</code> objects, one for each thread.</li><li><code>neighbour_caches=[NaturalNeighboursCache(tri) for _ in 1:Base.Threads.nthreads()]</code>: A vector of <code>NaturalNeighboursCache</code> objects, one for each thread.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parallel=true</code>: Whether to use multithreading or not.</li></ul><p><strong>Output</strong></p><ul><li><code>∇</code>: A vector of gradients at the data sites. Each element is a <code>Tuple</code> defining the gradient entries.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/NaturalNeighbours.jl/blob/badc110ac565b2ce7ee2e61d8d4944e30b156378/src/differentiation/generate.jl#L90-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaturalNeighbours.generate_derivatives" href="#NaturalNeighbours.generate_derivatives"><code>NaturalNeighbours.generate_derivatives</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_derivatives(
    tri,
    z,
    derivative_caches=[DerivativeCache(tri) for _ in 1:Base.Threads.nthreads()],
    neighbour_caches=[NaturalNeighboursCache(tri) for _ in 1:Base.Threads.nthreads()];
    parallel=true,
    method=Direct(),
    use_cubic_terms=true,
    alpha=0.1,
    initial_gradients=dwrap(method) == Direct() ? nothing : generate_gradients(tri, z, derivative_caches, neighbour_caches; method=dwrap(method), parallel, rng)
)</code></pre><p>Generate derivatives at the data sites defined by the triangulation <code>tri</code> with associated function values <code>tri</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tri</code>: A <code>Triangulation</code> object.</li><li><code>z</code>: A vector of function values at the data sites.</li><li><code>derivative_caches=[DerivativeCache(tri) for _ in 1:Base.Threads.nthreads()]</code>: A vector of <code>DerivativeCache</code> objects, one for each thread.</li><li><code>neighbour_caches=[NaturalNeighboursCache(tri) for _ in 1:Base.Threads.nthreads()]</code>: A vector of <code>NaturalNeighboursCache</code> objects, one for each thread.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>parallel=true</code>: Whether to use multithreading or not.</li><li><code>method=Direct()</code>: The method used for generating the derivatives. See <a href="#NaturalNeighbours.AbstractDifferentiator"><code>AbstractDifferentiator</code></a>.</li><li><code>use_cubic_terms=true</code>: Whether to use cubic terms for estimating the second order derivatives. Only relevant for <code>method == Direct()</code>.</li><li><code>alpha=0.1</code>: The weighting parameter used for estimating the second order derivatives. Only relevant for <code>method == Iterative()</code>.</li><li><code>initial_gradients=dwrap(method) == Direct() ? nothing : generate_gradients(tri, z, derivative_caches, neighbour_caches; method=dwrap(method), parallel)</code>: The initial gradients used for estimating the second order derivatives. Only relevant for <code>method == Iterative()</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>∇</code>: A vector of gradients at the data sites. Each element is a <code>Tuple</code> defining the gradient entries.</li><li><code>ℋ</code>: A vector of Hessians at the data sites. Each element is a <code>Tuple</code> defining the Hessian entries in the form <code>(H[1, 1], H[2, 2], H[1, 2])</code> (<code>H[2, 1]</code> is the same as <code>H[2, 2]</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/NaturalNeighbours.jl/blob/badc110ac565b2ce7ee2e61d8d4944e30b156378/src/differentiation/generate.jl#L31-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaturalNeighbours.AbstractInterpolator" href="#NaturalNeighbours.AbstractInterpolator"><code>NaturalNeighbours.AbstractInterpolator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractInterpolator{D}</code></pre><p>Abstract type for defining the method used for evaluating an interpolant. <code>D</code> is, roughly, defined to be  the smoothness at the data sites (currently only relevant for <code>Sibson</code>). The available subtypes are:</p><ul><li><code>Sibson(d)</code>: Interpolate via the Sibson interpolant, with <code>C(d)</code> continuity at the data sites. Only defined for <code>D ∈ (0, 1)</code>. If <code>D == 1</code>, gradients must be provided.</li><li><code>Triangle(d)</code>: Interpolate based on vertices of the triangle that the point resides in, with <code>C(0)</code> continuity at the data sites. <code>D</code> is ignored.</li><li><code>Nearest(d)</code>: Interpolate by returning the function value at the nearest data site. <code>D</code> doesn&#39;t mean much here (it could be <code>D = ∞</code>), and so it is ignored and replaced with <code>0</code>.</li><li><code>Laplace(d)</code>: Interpolate via the Laplace interpolant, with <code>C(0)</code> continuity at the data sites. <code>D</code> is ignored.</li><li><code>Farin(d)</code>: Interpolate using the Farin interpolant, with <code>C(1)</code> continuity at the data sites. <code>d</code> is ignored.</li><li><code>Hiyoshi(d)</code>: Interpolate using the Hiyoshi interpolant, with <code>C(d)</code> continuity at the data sites. Currently, only defined for <code>d == 2</code>.</li></ul><p>Our implementation of <code>Sibson(0)</code>&#39;s coordinates follows <a href="https://gwlucastrig.github.io/TinfourDocs/NaturalNeighborTinfourAlgorithm/index.html">this article</a> with some simple modifications.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/NaturalNeighbours.jl/blob/badc110ac565b2ce7ee2e61d8d4944e30b156378/src/interpolation/interpolate.jl#L41-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaturalNeighbours.AbstractDifferentiator" href="#NaturalNeighbours.AbstractDifferentiator"><code>NaturalNeighbours.AbstractDifferentiator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractDifferentiator end</code></pre><p>Abstract type for defining the method used for differentiating an interpolant or generating derivatives at data sites. </p><ul><li><code>Direct()</code>: Generate derivatives directly with one least squares problem.</li><li><code>Iterative()</code>: Generate derivatives iteratively: Gradients are estimated first, and then both gradients and Hessians are estimated with the initial gradients used to refine the results.  </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/NaturalNeighbours.jl/blob/badc110ac565b2ce7ee2e61d8d4944e30b156378/src/differentiation/generate.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaturalNeighbours.Sibson" href="#NaturalNeighbours.Sibson"><code>NaturalNeighbours.Sibson</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Sibson(d=0)</code></pre><p>Interpolate using Sibson&#39;s coordinates with <code>C(d)</code> continuity at the data sites.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/NaturalNeighbours.jl/blob/badc110ac565b2ce7ee2e61d8d4944e30b156378/src/interpolation/interpolate.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaturalNeighbours.Hiyoshi" href="#NaturalNeighbours.Hiyoshi"><code>NaturalNeighbours.Hiyoshi</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Hiyoshi(d=2)</code></pre><p>Interpolate using Hiyoshi&#39;s C(2) interpolant. Hiyoshi&#39;s interpolant C(0) is not yet implemented,  but we do not make any conversions to C(2) like in e.g. <code>Farin()</code>, e.g. <code>Farin()</code> gets  converted to <code>Farin(1)</code> but, to support possible later versions, <code>Hiyoshi()</code> does not get  converted to <code>Hiyoshi(2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/NaturalNeighbours.jl/blob/badc110ac565b2ce7ee2e61d8d4944e30b156378/src/interpolation/interpolate.jl#L89-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaturalNeighbours.Farin" href="#NaturalNeighbours.Farin"><code>NaturalNeighbours.Farin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Farin()</code></pre><p>Interpolate using Farin&#39;s C(1) interpolant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/NaturalNeighbours.jl/blob/badc110ac565b2ce7ee2e61d8d4944e30b156378/src/interpolation/interpolate.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaturalNeighbours.Laplace" href="#NaturalNeighbours.Laplace"><code>NaturalNeighbours.Laplace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Laplace()</code></pre><p>Interpolate using Laplace&#39;s coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/NaturalNeighbours.jl/blob/badc110ac565b2ce7ee2e61d8d4944e30b156378/src/interpolation/interpolate.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaturalNeighbours.Triangle" href="#NaturalNeighbours.Triangle"><code>NaturalNeighbours.Triangle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Triangle()</code></pre><p>Interpolate using a piecewise linear interpolant over the underlying triangulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/NaturalNeighbours.jl/blob/badc110ac565b2ce7ee2e61d8d4944e30b156378/src/interpolation/interpolate.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaturalNeighbours.Nearest" href="#NaturalNeighbours.Nearest"><code>NaturalNeighbours.Nearest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Nearest()</code></pre><p>Interpolate by taking the function value at the nearest data site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/NaturalNeighbours.jl/blob/badc110ac565b2ce7ee2e61d8d4944e30b156378/src/interpolation/interpolate.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaturalNeighbours.Direct" href="#NaturalNeighbours.Direct"><code>NaturalNeighbours.Direct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Direct()</code></pre><p>Generate derivatives directly with one least squares problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/NaturalNeighbours.jl/blob/badc110ac565b2ce7ee2e61d8d4944e30b156378/src/differentiation/generate.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaturalNeighbours.Iterative" href="#NaturalNeighbours.Iterative"><code>NaturalNeighbours.Iterative</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Iterative()</code></pre><p>Generate derivatives iteratively: Gradients are estimated first, and then both gradients and Hessians are estimated with the initial gradients used to refine the results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/NaturalNeighbours.jl/blob/badc110ac565b2ce7ee2e61d8d4944e30b156378/src/differentiation/generate.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NaturalNeighbours.identify_exterior_points" href="#NaturalNeighbours.identify_exterior_points"><code>NaturalNeighbours.identify_exterior_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">identify_exterior_points(x, y, points, boundary_nodes; tol = 0.0)</code></pre><p>Given a polygon described by <code>(points, boundary_nodes)</code>, matching the  specification of polygons in DelaunayTriangulation.jl (see <a href="https://danielvandh.github.io/DelaunayTriangulation.jl/dev/boundary_handling/">here</a>), returns a vector of indices of the points defined by <code>(x, y)</code> that are outside of the polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/NaturalNeighbours.jl/blob/badc110ac565b2ce7ee2e61d8d4944e30b156378/src/utils.jl#L1-L7">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="interpolation/">Interpolation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 30 May 2023 22:55">Tuesday 30 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
