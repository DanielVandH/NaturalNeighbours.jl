<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interpolation Details · NaturalNeighbours.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://DanielVandH.github.io/NaturalNeighbours.jl/interpolation_math/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NaturalNeighbours.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../interpolation/">Interpolation</a></li><li><a class="tocitem" href="../differentiation/">Differentiaton</a></li><li><a class="tocitem" href="../swiss/">Switzerland Elevation Data</a></li></ul></li><li><a class="tocitem" href="../compare/">Comparison of Interpolation Methods</a></li><li><span class="tocitem">Mathematical Details</span><ul><li class="is-active"><a class="tocitem" href>Interpolation Details</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Voronoi-Tessellation"><span>Voronoi Tessellation</span></a></li><li class="toplevel"><a class="tocitem" href="#Natural-Neighbours"><span>Natural Neighbours</span></a></li><li class="toplevel"><a class="tocitem" href="#Natural-Neighbour-Coordinates"><span>Natural Neighbour Coordinates</span></a></li><li class="toplevel"><a class="tocitem" href="#Natural-Neighbour-Interpolation"><span>Natural Neighbour Interpolation</span></a></li><li class="toplevel"><a class="tocitem" href="#Some-Local-Coordinates"><span>Some Local Coordinates</span></a></li><li><a class="tocitem" href="#Nearest-Neighbours"><span>Nearest Neighbours</span></a></li><li><a class="tocitem" href="#Laplace-Coordinates"><span>Laplace Coordinates</span></a></li><li><a class="tocitem" href="#Sibson-Coordinates"><span>Sibson Coordinates</span></a></li><li><a class="tocitem" href="#Triangle-Coordinates"><span>Triangle Coordinates</span></a></li><li class="toplevel"><a class="tocitem" href="#Smooth-Interpolation"><span>Smooth Interpolation</span></a></li><li><a class="tocitem" href="#Sibson&#39;s-C1-Interpolant"><span>Sibson&#39;s <span>$C^1$</span> Interpolant</span></a></li><li><a class="tocitem" href="#Farin&#39;s-C1-Interpolant"><span>Farin&#39;s <span>$C^1$</span> Interpolant</span></a></li><li><a class="tocitem" href="#Hiyoshi&#39;s-C2-Interpolant"><span>Hiyoshi&#39;s <span>$C^2$</span> Interpolant</span></a></li><li class="toplevel"><a class="tocitem" href="#Regions-of-Influence"><span>Regions of Influence</span></a></li><li class="toplevel"><a class="tocitem" href="#Extrapolation"><span>Extrapolation</span></a></li></ul></li><li><a class="tocitem" href="../differentiation_math/">Differentiation Details</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Mathematical Details</a></li><li class="is-active"><a href>Interpolation Details</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interpolation Details</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/NaturalNeighbours.jl/blob/main/docs/src/interpolation_math.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Interpolation"><a class="docs-heading-anchor" href="#Interpolation">Interpolation</a><a id="Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation" title="Permalink"></a></h1><p>In this section, we give some of the mathematical background behind natural neighbour interpolation, and other interpolation methods provided from this package. The discussion here will be limited, but you can see this <a href="https://kluedo.ub.rptu.de/frontdoor/deliver/index/docId/2104/file/diss.bobach.natural.neighbor.20090615.pdf">thesis</a> or this <a href="https://en.wikipedia.org/wiki/Natural_neighbor_interpolation">Wikipedia article</a> for more information. The discussion that follows is primarily sourced from the linked thesis. These ideas are implemented by the <code>interpolate</code> function.</p><h1 id="Voronoi-Tessellation"><a class="docs-heading-anchor" href="#Voronoi-Tessellation">Voronoi Tessellation</a><a id="Voronoi-Tessellation-1"></a><a class="docs-heading-anchor-permalink" href="#Voronoi-Tessellation" title="Permalink"></a></h1><p>We need to first define the <em>Voronoi tessellation</em>. We consider some set of points <span>$\boldsymbol X = \{\boldsymbol x_1, \ldots, \boldsymbol x_m\} \subseteq \mathbb R^2$</span>. The Voronoi tessellation of <span>$\boldsymbol X$</span>, denoted <span>$\mathcal V(\boldsymbol X)$</span>, is a set of convex polygons <span>$\{V_{\boldsymbol x_1}, \ldots, V_{\boldsymbol x_m}\}$</span>, also called <em>tiles</em>, such that </p><p class="math-container">\[\begin{equation*}
V_{\boldsymbol x_i} = \{\boldsymbol x \in \mathbb R^2 : \|\boldsymbol x - \boldsymbol x_i\| \leq \|\boldsymbol x - \boldsymbol x_j\|,~ \boldsymbol x_j \in \boldsymbol X\}.
\end{equation*}\]</p><p>In particular, any point in <span>$V_{\boldsymbol x_i}$</span> is closer to <span>$\boldsymbol x_i$</span> than it is to any other point in <span>$\boldsymbol X$</span>. We will also denote <span>$V_{\boldsymbol x_i}$</span> by <span>$V_i$</span>. <a href="https://github.com/DanielVandH/DelaunayTriangulation.jl">DelaunayTriangulation.jl</a> is used to build <span>$\mathcal V(\boldsymbol X)$</span>. An example of a Voronoi tessellation is shown below.</p><figure>
    <img src='../figures/example_tessellation.png', alt='Voronoi Tessellation'><br>
</figure><h1 id="Natural-Neighbours"><a class="docs-heading-anchor" href="#Natural-Neighbours">Natural Neighbours</a><a id="Natural-Neighbours-1"></a><a class="docs-heading-anchor-permalink" href="#Natural-Neighbours" title="Permalink"></a></h1><p>See that the tiles of the tessellation in the figure above intersect along a line, called the <em>Voronoi facet</em>, that we denote by <span>$\mathcal F_{ij} = \mathcal V_i \cap \mathcal V_j$</span>. Whenever <span>$\mathcal F_{ij} \neq \emptyset$</span>, we say that <span>$\boldsymbol x_i$</span> and <span>$\boldsymbol x_j$</span> are <em>natural neighbours</em> in <span>$\boldsymbol X$</span>. We denote the set of natural neighbours to a point <span>$\boldsymbol x \in \boldsymbol X$</span> by <span>$N(\boldsymbol x) \subseteq \boldsymbol X$</span>, and we denote the corresponding indices by <span>$N_i = \{j : \boldsymbol x_j \in N(\boldsymbol x_j)\}$</span>.</p><h1 id="Natural-Neighbour-Coordinates"><a class="docs-heading-anchor" href="#Natural-Neighbour-Coordinates">Natural Neighbour Coordinates</a><a id="Natural-Neighbour-Coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Natural-Neighbour-Coordinates" title="Permalink"></a></h1><p>We represent points locally using what are known as natural neighbour coordinates, which are based on the nearby Voronoi tiles. In particular, we make the following definition: Any set of convex coordinates <span>$\boldsymbol \lambda$</span> (convex means that <span>$\lambda_i \geq 0$</span> for each <span>$i$</span>) of <span>$\boldsymbol x$</span> with respect to the natural neighbours <span>$N(\boldsymbol x)$</span> of <span>$\boldsymbol x$</span> that satisfies: </p><ol><li><span>$\lambda_i &gt; 0 \iff \boldsymbol x_i \in N(\boldsymbol x)$</span>,</li><li><span>$\boldsymbol \lambda$</span> is continuous with respect to <span>$\boldsymbol x$</span>, </li></ol><p>is called a set of <em>natural neighbour coordinates</em> of <span>$\boldsymbol x$</span> in <span>$\boldsymbol X$</span>, or just the natural neighbour coordinates of <span>$\boldsymbol x$</span>, or the <em>local coordinates</em> of <span>$\boldsymbol x$</span>.</p><h1 id="Natural-Neighbour-Interpolation"><a class="docs-heading-anchor" href="#Natural-Neighbour-Interpolation">Natural Neighbour Interpolation</a><a id="Natural-Neighbour-Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Natural-Neighbour-Interpolation" title="Permalink"></a></h1><p>Now that we have some definitions, we can actually define the steps involved in natural neighbour interpolation. We are supposing that we have some data <span>$(\boldsymbol x_i, z_i)$</span> for <span>$i=1,\ldots,m$</span>, and we want to interpolate this data at some point <span>$\boldsymbol x_0 \in \mathcal C(\boldsymbol X)$</span>, where <span>$\boldsymbol X$</span> is the point set <span>$(\boldsymbol x_1,\ldots,\boldsymbol x_m)$</span> and <span>$\mathcal C(\boldsymbol X)$</span> is the convex hull of <span>$\boldsymbol x$</span>. We let <span>$Z$</span> denote the function values <span>$(z_1,\ldots,z_m)$</span>.</p><p>The steps are relatively straight forward.</p><ol><li>First, compute local coordinates <span>$\boldsymbol \lambda(\boldsymbol x_0)$</span> with respect to the natural neighbours <span>$N(\boldsymbol x_0)$</span>.</li><li>Combine the values <span>$z_i$</span> associated with <span>$\boldsymbol x_i \in N(\boldsymbol x)$</span> using some blending function <span>$\varphi(\boldsymbol \lambda, Z)$</span>.</li></ol><p>To consider the second step, note that a major motivation for working with local coordinates is the following fact: The coordinates <span>$\boldsymbol \lambda$</span> that we compute can be used to represent our point <span>$\boldsymbol x_0$</span> as <span>$\boldsymbol x_0 = \sum_{i \in N_0} \lambda_i(\boldsymbol x_0)\boldsymbol x_i$</span>, a property known as the local coordinates property (<a href="https://doi.org/10.1017/S0305004100056589">Sibson, 1980</a>), or the natural neighbour coordinates property if <span>$\boldsymbol \lambda$</span> is convex (as we assume them to be). </p><p>In particular, the coordinates <span>$\boldsymbol \lambda$</span> determine how much each point <span>$\boldsymbol x_i \in N(\boldsymbol x_0)$</span> contributes to the representation of our query point <span>$\boldsymbol x_0$</span>, hence the term &quot;natural&quot;. So, a natural interpolant is to simply take this linear combination and replace <span>$\boldsymbol x_i$</span> by <span>$z_i$</span>, giving the scattered data interpolant</p><p class="math-container">\[f(\boldsymbol x_0) = \sum_{i \in N_0} \lambda_i z_i.\]</p><p>Note that the natural neighbour coordinates property only works for points in the convex hull of <span>$\boldsymbol X$</span> (otherwise <span>$\boldsymbol \lambda$</span> is not convex), hence the restriction <span>$\boldsymbol x_0 \in \mathcal C(\boldsymbol X)$</span>.</p><h1 id="Some-Local-Coordinates"><a class="docs-heading-anchor" href="#Some-Local-Coordinates">Some Local Coordinates</a><a id="Some-Local-Coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Some-Local-Coordinates" title="Permalink"></a></h1><p>Let us now define all the coordinates we provide in this package.</p><h2 id="Nearest-Neighbours"><a class="docs-heading-anchor" href="#Nearest-Neighbours">Nearest Neighbours</a><a id="Nearest-Neighbours-1"></a><a class="docs-heading-anchor-permalink" href="#Nearest-Neighbours" title="Permalink"></a></h2><p>To represent a point <span>$\boldsymbol x_0$</span>, we can use what are known as <em>nearest neighbour coordinates</em>, which simply assigns a weight of <span>$1$</span> to the generator of the tile that <span>$\boldsymbol x_0$</span> is in:</p><p class="math-container">\[\lambda_i^{\text{NEAR}} = \begin{cases} 1 &amp; \boldsymbol x_0 \in \mathcal V_i, \\ 0 &amp; \text{otherwise}. \end{cases}\]</p><p>The resulting scatterd data interpolant <span>$f^{\text{NEAR}}$</span> is then just </p><p class="math-container">\[f^{\text{NEAR}}(\boldsymbol x) = z_i, \]</p><p>where <span>$\boldsymbol x \in \mathcal V_i$</span>. An example of what this interpolant looks like is given below.</p><figure>
    <img src='../figures/fnear_example.png', alt='Nearest Neighbour Interpolation'><br>
</figure><h2 id="Laplace-Coordinates"><a class="docs-heading-anchor" href="#Laplace-Coordinates">Laplace Coordinates</a><a id="Laplace-Coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Laplace-Coordinates" title="Permalink"></a></h2><p>Here we introduce <em>Laplace coordinates</em>, also known as <em>non-Sibsonian coordinates</em>. To define these coordinates, let us take some tessellation <span>$\mathcal V(\boldsymbol X)$</span> and see what happens when we add a point into it.</p><figure>
    <img src='../figures/new_tile.png', alt='Tessellation with a new point'><br>
</figure><p>In the figure above, the tiles with the black boundaries and no fill are the tiles of the original tessellation, and we show the tile that would be created by some query point <span>$\boldsymbol x_0$</span> (the magenta point) with a blue tile. We see that the insertion of <span>$\boldsymbol x_0$</span> into the tessellation has intersected some of the other tiles, in particular it has modified only the tiles corresponding to its natural neighbours in N(\boldsymbol x_0).</p><p>For a given generator <span>$\boldsymbol x_i \in N(\boldsymbol x_0)$</span>, we see that there is a corresponding blue line passing through its tile. Denote this blue line by <span>$\mathcal F_{0i}$</span>, and let <span>$r_i = \|\boldsymbol x_0 - \boldsymbol x_i\|$</span>. With this definition, we define </p><p class="math-container">\[\lambda_i^{\text{LAP}} = \frac{\hat\lambda_i^{\text{LAP}}}{\sum_{j \in N_0} \hat\lambda_j^{\text{LAP}}}, \quad \hat\lambda_i^{\text{LAP}} = \frac{\ell(\mathcal F_{0i})}{r_i},\]</p><p>where <span>$\ell(\mathcal F_{0i})$</span> is the length of the facet <span>$\mathcal F_{0i}$</span>. In particular, <span>$\hat\lambda_i^{\text{LAP}}$</span> is the ratio of the blue line inside the tile and the distance between the generator <span>$\boldsymbol x_i$</span> and the query point <span>$\boldsymbol x_0$</span>. These coordinates are continuous in <span>$\mathcal C(\boldsymbol X)$</span> with derivative discontinuities at the data sites <span>$\boldsymbol X$</span>. The resulting interpolant <span>$f^{\text{LAP}}$</span> inherits these properties, where </p><p class="math-container">\[f^{\text{LAP}}(\boldsymbol x_0) = \sum_{i \in N_0} \lambda_i^{\text{LAP}}z_i.\]</p><p>This interpolant has linear precision, meaning it reproduces linear functions.</p><p>An example of what this interpolant looks like is given below.</p><figure>
    <img src='../figures/flap_example.png', alt='Laplace Interpolation'><br>
</figure><h2 id="Sibson-Coordinates"><a class="docs-heading-anchor" href="#Sibson-Coordinates">Sibson Coordinates</a><a id="Sibson-Coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Sibson-Coordinates" title="Permalink"></a></h2><p>Now we consider Sibson&#39;s coordinates. These coordinates are similar to Laplace&#39;s coordinates, except we consider the areas rather than lengths for the facets. In particular, let us return to the figure above, reprinted below for convenience:</p><figure>
    <img src='../figures/new_tile.png', alt='Tessellation with a new point'><br>
</figure><p>The idea is to consider how much area this new blue tile &quot;steals&quot; from the tiles of its natural neighbours. Based on the following identity (<a href="https://doi.org/10.1017/S0305004100056589">Sibson, 1980</a>),</p><p class="math-container">\[\text{Area}(\mathcal V_{\boldsymbol x_0}) \boldsymbol x = \sum_{i \in N_0} \text{Area}(\mathcal V_{\boldsymbol x} \cap \mathcal V_{\boldsymbol x_i}^{\boldsymbol x_0})\boldsymbol x_i,\]</p><p>where <span>$\mathcal V_{\boldsymbol x_0}$</span> is the new tile shown in blue, and <span>$\mathcal V_{\boldsymbol x_i}^{\boldsymbol x_0}$</span> is the tile associated with <span>$\boldsymbol x_i$</span> in the original tessellation, i.e. prior to the insertion of <span>$\boldsymbol x_0$</span>, we define <em>Sibson&#39;s coordinates</em> as </p><p class="math-container">\[\lambda_i^{\text{SIB}} = \frac{\hat\lambda_i^{\text{SIB}}}{\sum_{j \in N_0} \hat\lambda_j^{\text{SIB}}}, \quad \hat\lambda_i^{\text{SIB}} = \text{Area}(\mathcal V_{\boldsymbol x_0} \cap \mathcal V_{\boldsymbol x_i}^{\boldsymbol x_0}).\]</p><p>A clearer way to write this is as </p><p class="math-container">\[\lambda_i^{\text{SIB}} = \frac{A(\boldsymbol x_i)}{A(\boldsymbol x)},\]</p><p>where <span>$A(\boldsymbol x_i)$</span> is the area of the intersection between the original tile for <span>$\boldsymbol x_i$</span> and the new tile at <span>$\boldsymbol x_0$</span>, and <span>$A(\boldsymbol x)$</span> is the total area of the new blue tile. These coordinates are <span>$C^1$</span> continuous in <span>$\mathcal C(\boldsymbol X) \setminus \boldsymbol X$</span>, with derivative discontinuities at the data sites, and so too is the interpolant </p><p class="math-container">\[f^{\text{SIB}}(\boldsymbol x_0) = \sum_{i \in N_0} \lambda_i^{\text{SIB}}z_i.\]</p><p>We may also use <span>$f^{\text{SIB}0}$</span> and <span>$\lambda_i^{\text{SIB}0}$</span> rather than <span>$f^{\text{SIB}}$</span> and <span>$\lambda_i^{\text{SIB}}$</span>, respectively. </p><p>This interpolant has linear precision, meaning it reproduces linear functions.</p><p>An example of what this interpolant looks like is given below.</p><figure>
    <img src='../figures/fsib0_example.png', alt='Sibson Interpolation'><br>
</figure><p>Our implementation of these coordinates follows <a href="https://gwlucastrig.github.io/TinfourDocs/NaturalNeighborTinfourAlgorithm/index.html">this article</a> with some simple modifications.</p><h2 id="Triangle-Coordinates"><a class="docs-heading-anchor" href="#Triangle-Coordinates">Triangle Coordinates</a><a id="Triangle-Coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Triangle-Coordinates" title="Permalink"></a></h2><p>Now we define triangle coordinates. These are not actually natural coordinates (they are not continuous in <span>$\boldsymbol x$</span>), but they just give a nice comparison with other methods. The idea is to interpolate based on the barycentric coordinates of the triangle that the query point is in, giving rise to a piecewise linear interpolant over <span>$\mathcal C(\boldsymbol X)$</span>.</p><p>Let us take our query point <span>$\boldsymbol x=(x,y)$</span> and suppose it is in some triangle <span>$V$</span> with coordinates <span>$\boldsymbol x_1 = (x_1,y_1)$</span>, <span>$\boldsymbol x_2 = (x_2,y_2)$</span>, and <span>$\boldsymbol x_3=(x_3,y_3)$</span>. We can then define:</p><p class="math-container">\[\begin{align*}
\Delta &amp;= (y_2-y_3)(x_1-x_3)+(x_3-x_2)(y_1-y_3), \\
\lambda_1 &amp;= \frac{(y_2-y_3)(x-x_3)+(x_3-x_2)(y-y_3)}{\Delta}, \\
\lambda_2 &amp;= \frac{(y_3-y_1)(x-x_3) + (x_1-x_3)(y-y_3)}{\Delta}, \\
\lambda_3 &amp;= 1-\lambda_1-\lambda_2.
\end{align*}\]</p><p>With these definitions, our interpolant is </p><p class="math-container">\[f^{\text{TRI}}(\boldsymbol x) = \lambda_1z_1 + \lambda_2z_2 + \lambda_3z_3.\]</p><p>(Of course, the subscripts would have to be modified to match the actual indices of the points rather than assuming them to be <span>$\boldsymbol x_1$</span>, <span>$\boldsymbol x_2$</span>, and <span>$\boldsymbol x_3$</span>.) This is the same interpolant used in <a href="https://github.com/DanielVandH/FiniteVolumeMethod.jl">FiniteVolumeMethod.jl</a>.</p><p>An example of what this interpolant looks like is given below.</p><figure>
    <img src='../figures/ftri_example.png', alt='Triangle Interpolation'><br>
</figure><h1 id="Smooth-Interpolation"><a class="docs-heading-anchor" href="#Smooth-Interpolation">Smooth Interpolation</a><a id="Smooth-Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Smooth-Interpolation" title="Permalink"></a></h1><p>All the derived interpolants above are not differentiable at the data sites. Here we describe some interpolants that are differentiable at the data sites. </p><h2 id="Sibson&#39;s-C1-Interpolant"><a class="docs-heading-anchor" href="#Sibson&#39;s-C1-Interpolant">Sibson&#39;s <span>$C^1$</span> Interpolant</a><a id="Sibson&#39;s-C1-Interpolant-1"></a><a class="docs-heading-anchor-permalink" href="#Sibson&#39;s-C1-Interpolant" title="Permalink"></a></h2><p>Sibson&#39;s <span>$C^1$</span> interpolant, which we call Sibson-1 interpolation, extends on Sibon&#39;s coordinates above, also called Sibson-0 coordinates, is <span>$C^1$</span> at the data sites. A limitation of it is that it requires an estimate of the gradient <span>$\boldsymbol \nabla_i$</span> at the data sites <span>$\boldsymbol x_i$</span>, which may be estimated using the derivative generation techniques describd in the sidebar. </p><p>Following <a href="https://kluedo.ub.rptu.de/frontdoor/deliver/index/docId/2104/file/diss.bobach.natural.neighbor.20090615.pdf">Bobach&#39;s thesis</a> or <a href="https://theses.hal.science/tel-00832487/PDF/these-flototto.pdf">Flötotto&#39;s thesis</a>, the Sibson-1 interpolant <span>$f^{\text{SIB}1}$</span> is a linear combination of <span>$f^{\text{SIB}0} \equiv f^{\text{SIB}}$</span> and another interpolant <span>$\xi$</span>. We define:</p><p class="math-container">\[\begin{align*}
r_i &amp;= \|\boldsymbol x_0-\boldsymbol x_i\|, \\
\gamma_i &amp;= \frac{\lambda_i^{\text{SIB}0}}{r_i}, \\
\zeta_i &amp;= z_i + (\boldsymbol x_0 - \boldsymbol x_i)^T\boldsymbol\nabla_i, \\
\zeta &amp;= \frac{\sum_{i\in N_0} \gamma_i\zeta_i}{\sum_{i\in N_0} \gamma_i}, \\
\alpha &amp;= \frac{\sum_{i \in N_0} \lambda_i^{\text{SIB}0}r_i}{\sum_{i \in N_0} \gamma_i}, \\
\beta &amp;= \sum_{i \in N_0} \lambda_i^{\text{SIB}0}r_i^2.
\end{align*}\]</p><p>Our interpolant is then defined by </p><p class="math-container">\[f^{\text{SIB}1}(\boldsymbol x_0) = \frac{\alpha f^{\text{SIB}0} + \beta\zeta}{\alpha + \beta}.\]</p><p>This interpolant exactly reproduces spherical quadratics <span>$\boldsymbol x \mapsto \mu(\boldsymbol x - \boldsymbol a)^T(\boldsymbol x - \boldsymbol a)$</span>.</p><p>An example of what this interpolant looks like is given below.</p><figure>
    <img src='../figures/fsib1_example.png', alt='Sibson-1 Interpolation'><br>
</figure><p>Notice that the peak of the function is much smoother than it was in the other interpolant examples.</p><h2 id="Farin&#39;s-C1-Interpolant"><a class="docs-heading-anchor" href="#Farin&#39;s-C1-Interpolant">Farin&#39;s <span>$C^1$</span> Interpolant</a><a id="Farin&#39;s-C1-Interpolant-1"></a><a class="docs-heading-anchor-permalink" href="#Farin&#39;s-C1-Interpolant" title="Permalink"></a></h2><p>Farin&#39;s <span>$C^1$</span> interpolant, introduced by <a href="https://doi.org/10.1016/0167-8396(90)90036-Q">Farin (1990)</a>, is another interpolant with <span>$C^1$</span> continuity at the data sites provided we have estimates of the gradients <span>$\boldsymbol \nabla_i$</span> at the data sites (see the sidebar for derivative generation methods), and also makes use of the Sibson-0 coordinates. Typically these coordinates are described in the language of Bernstein-Bézier simplices (as in <a href="https://kluedo.ub.rptu.de/frontdoor/deliver/index/docId/2104/file/diss.bobach.natural.neighbor.20090615.pdf">Bobach&#39;s thesis</a> or <a href="https://theses.hal.science/tel-00832487/PDF/these-flototto.pdf">Flötotto&#39;s thesis</a> and Farin&#39;s original paper), this language makes things more complicated than they need to be. Instead, we describe the interpolant using symmetric homogeneous polynomials, as in Hiyoshi and Sugihara (<a href="https://doi.org/10.1007/978-3-540-24767-8_8">2004</a>, <a href="https://doi.org/10.1504/IJCSE.2007.014460">2007</a>). See the references mentioned above for a derivation of the interpolant we describe below.</p><p>Let <span>$\boldsymbol x_0$</span> be some point in <span>$\mathcal C(\boldsymbol X)$</span> and let <span>$N_0$</span> be the natural neighbourhood around <span>$\boldsymbol x_0$</span>. We let the natural coordinates be given by Sibson&#39;s coordinates <span>$\boldsymbol \lambda = (\lambda_1,\ldots,\lambda_n)$</span> with corresponding natural neighbours <span>$\boldsymbol x_1,\ldots,\boldsymbol x_n$</span> (rearranging the indices accordingly to avoid using e.g. <span>$i_1,\ldots, i_n$</span>), where <span>$n = |N_0|$</span>. We define a homogeneous symmetric polynomial </p><p class="math-container">\[f(\boldsymbol x_0) = \sum_{i \in N_0}\sum_{j \in N_0}\sum_{k \in N_0} f_{ijk}\lambda_i\lambda_j\lambda_k,\]</p><p>where the coefficients <span>$f_{ijk}$</span> are symmetric so that they can be uniquely determined. We define <span>$z_{i, j} = \boldsymbol \nabla_i^T \overrightarrow{\boldsymbol x_i\boldsymbol x_j}$</span>, where <span>$\boldsymbol \nabla_i$</span> is the estimate of the gradient at <span>$\boldsymbol x_i \in N(\boldsymbol x_0) \subset \boldsymbol X$</span> and <span>$\overrightarrow{\boldsymbol x_i\boldsymbol x_j} = \boldsymbol x_j - \boldsymbol x_i$</span>. Then, define the coefficients (using symmetry to permute the indices to the standard forms below):</p><p class="math-container">\[\begin{align*}
f_{iii} &amp;= z_i, \\
f_{iij} &amp;= z_i + \frac{1}{3}z_{i,j},  \\
f_{ijk} &amp;= \frac{z_i+z_j+z_k}{3} + \frac{z_{i,j}+z_{i,k}+z_{j,i}+z_{j,k}+z_{k,i}+z_{k,j}}{12},
\end{align*}\]</p><p>where all the <span>$i$</span>, <span>$j$</span>, and <span>$k$</span> are different. The resulting interpolant <span>$f$</span> is Farin&#39;s <span>$C^1$</span> interpolant, <span>$f^{\text{FAR}} = f$</span>, and has quadratic precision so that it reproduces quadratic polynomials.</p><p>Let us describe how we actually evaluate <span>$\sum_{i \in N_0}\sum_{j \in N_0}\sum_{k \in N_0} f_{ijk}\lambda_i\lambda_j\lambda_k$</span> efficiently. Write this as</p><p class="math-container">\[f^{\text{FAR}}(\boldsymbol x_0) = \sum_{1 \leq i, j, k \leq n} f_{ijk}\lambda_i\lambda_j\lambda_k.\]</p><p>This looks close to the definition of a <a href="https://en.wikipedia.org/wiki/Complete_homogeneous_symmetric_polynomial">complete homogeneous symetric polynomial</a>. This page shows the identity</p><p class="math-container">\[\sum_{1 \leq i \leq j \leq k \leq n} X_iX_kX_j = \sum_{1 \leq i, j, k \leq n} \frac{m_i!m_j!m_k!}{3!}X_iX_jX_k,\]</p><p>where <span>$m_\ell$</span> is the multiplicity of <span>$X_\ell$</span> in the summand, e.g. if the summand is <span>$X_i^2X_k$</span> then <span>$m_i=2$</span> and <span>$m_k = 1$</span>. Thus, transforming the variables accordingly, we can show that </p><p class="math-container">\[f^{\text{FAR}}(\boldsymbol x_0) = 6\underbrace{\sum_{i=1}^n\sum_{j=i}^n\sum_{k=j}^n}_{\sum_{1 \leq i \leq j \leq k \leq n}} \tilde f_{ijk}\lambda_i\lambda_j\lambda_k,\]</p><p>where <span>$\tilde f_{iii} = f_{iii}/3! = f_{iii}/6$</span>, <span>$\tilde f_{iij} = f_{iij}/2$</span>, and <span>$\tilde f_{ijk} = f_{ijk}$</span>. This is the implementation we use.</p><h2 id="Hiyoshi&#39;s-C2-Interpolant"><a class="docs-heading-anchor" href="#Hiyoshi&#39;s-C2-Interpolant">Hiyoshi&#39;s <span>$C^2$</span> Interpolant</a><a id="Hiyoshi&#39;s-C2-Interpolant-1"></a><a class="docs-heading-anchor-permalink" href="#Hiyoshi&#39;s-C2-Interpolant" title="Permalink"></a></h2><p>Hiyoshi&#39;s <span>$C^2$</span> interpolant is similar to Farin&#39;s <span>$C^1$</span> interpolant, except now we have <span>$C^2$</span> continuity at the data sites and we now, in addition to requiring estimates of the gradients <span>$\boldsymbol \nabla_i$</span> at the data sites, require estimates of the Hessians <span>$\boldsymbol H_i$</span> at the data sites (see the sidebar for derivative generation methods). As with Farin&#39;s <span>$C^1$</span> interpolant, we use the language of homogeneous symmetric polynomials rather than Bernstein-Bézier simplices in what follows. There are two definitions of Hiyoshi&#39;s <span>$C^2$</span> interpolant, the first being given by <a href="https://doi.org/10.1007/978-3-540-24767-8_8">Hiyoshi and Sugihara (2004)</a> and described by <a href="https://kluedo.ub.rptu.de/frontdoor/deliver/index/docId/2104/file/diss.bobach.natural.neighbor.20090615.pdf">Bobach</a>, and the second given three years later again by  <a href="https://doi.org/10.1504/IJCSE.2007.014460">Hiyoshi and Sugihara (2007)</a>. We use the 2007 definition - testing shows that they are basically the same, anyway.</p><p>Like in the previous section, w let <span>$\boldsymbol x_0$</span> be some point in <span>$\mathcal C(\boldsymbol X)$</span> and let <span>$N_0$</span> be the natural neighbourhood around <span>$\boldsymbol x_0$</span>. We let the natural coordinates be given by Sibson&#39;s coordinates <span>$\boldsymbol \lambda = (\lambda_1,\ldots,\lambda_n)$</span> with corresponding natural neighbours <span>$\boldsymbol x_1,\ldots,\boldsymbol x_n$</span> (rearranging the indices accordingly to avoid using e.g. <span>$i_1,\ldots, i_n$</span>), where <span>$n = |N_0|$</span>. We define </p><p class="math-container">\[z_{i, j} = \boldsymbol \nabla_i^T\overrightarrow{\boldsymbol x_i\boldsymbol x_j}, \qquad z_{i, jk} = \overrightarrow{\boldsymbol x_i\boldsymbol x_j}^T\boldsymbol H_i\overrightarrow{\boldsymbol x_i\boldsymbol x_k}.\]</p><p>Hiyoshi&#39;s <span>$C^2$</span> interpolant, written <span>$f^{\text{HIY}}$</span> (or later <span>$f^{\text{HIY}2}$</span>, if ever we can get Hiyoshi&#39;s <span>$C^k$</span> interpolant on <span>$\mathcal C(\boldsymbol X) \setminus \boldsymbol X$</span> implemented –- see Hiyoshi and Sugihara (<a href="https://doi.org/10.1145/336154.336210">2000</a>, <a href="https://doi.org/10.1016/S0925-7721(01)00052-9">2002</a>), <a href="https://doi.org/10.1007/11919629_20">Bobach, Bertram, Umlauf (2006)</a>, and Chapter 3.2.5.5 and Chapter 5.5. of <a href="(https:/kluedo.ub.rptu.de/frontdoor/deliver/index/docId/2104/file/diss.bobach.natural.neighbor.20090615.pdf)">Bobach&#39;s thesis</a>), is defined by the homogeneous symmetric polynomial</p><p class="math-container">\[f^{\text{HIY}}(\boldsymbol x_0) = \sum_{1 \leq i,j,k,\ell,m \leq n} f_{ijk\ell m}\lambda_i\lambda_j\lambda_k\lambda_\ell\lambda_m,\]</p><p>where we define the coefficients (using symmetry to permute the indices to the standard forms below):</p><p class="math-container">\[\begin{align*}
f_{iiiii} &amp;= z_i, \\
f_{iiiij} &amp;= z_i + \frac15z_{i,j}, \\
f_{iiijj} &amp;= z_i + \frac25z_{i,j} + \frac{1}{20}z_{i,jj}, \\
f_{iiijk} &amp;= z_i + \frac15\left(z_{i, j} + z_{i, k}\right) + \frac{1}{20}z_{i, jk}, \\
f_{iijjk} &amp;= \frac{13}{30}\left(z_i + z_j\right) + \frac{2}{15}z_k + \frac{1}{9}\left(z_{i, j} + z_{j, i}\right) + \frac{7}{90}\left(z_{i, k} + z_{j, k}\right) \\&amp;+ \frac{2}{45}\left(z_{k, i} + z_{k, j}\right) + \frac{1}{45}\left(z_{i, jk} + z_{j, ik} + z_{k, ij}\right), \\
f_{iijk\ell} &amp;= \frac12z_i + \frac16\left(z_j + z_k + z_\ell\right) + \frac{7}{90}\left(z_{i, j} + z_{i, k} + z_{i, \ell}\right) \\&amp;+ \frac{2}{45}\left(z_{j, i} + z_{k, i} + z_{\ell, i}\right) + \frac{1}{30}\left(z_{j, k} + z_{j, \ell} + z_{k, j} + z_{k, \ell} + z_{\ell, j} + z_{j, k}\right) \\
&amp;+ \frac{1}{90}\left(z_{i, jk} + z_{i, j\ell} + z_{i, k\ell}\right) + \frac{1}{90}\left(z_{j, ik} + z_{j, i\ell} + z_{k, ij} + z_{k, i\ell} + z_{\ell, ij} + z_{\ell, ik}\right) \\&amp;+ \frac{1}{180}\left(z_{j, k\ell} + z_{k, j\ell} + z_{\ell, jk}\right), \\
f_{ijk\ell m} &amp;= \frac{1}{5}\left(z_i + z_j + z_k + z_\ell + z_m\right) \\
&amp;+ \frac{1}{30}\left(z_{i, j} + z_{i, k} + z_{i, \ell} + z_{i, m} + z_{j, i} + \cdots + z_{m, \ell}\right) \\
&amp;+ \frac{1}{180}\left(z_{i, jk} + z_{i, j\ell} + z_{i, jm} + z_{i, k\ell} + z_{i, km} + z_{i, \ell m} + z_{j, i\ell} + \cdots + z_{mk\ell}\right),
\end{align*}\]</p><p>where all the <span>$i$</span>, <span>$j$</span>, <span>$k$</span>, <span>$\ell$</span>, and <span>$m$</span> are different. To evaluate <span>$f^{\text{HIY}}$</span>, we use the same relationship between <span>$f^{\text{HIY}}$</span> and complete homogeneous symmetric polynomials to write</p><p class="math-container">\[f^{\text{HIY}}(\boldsymbol x_0) = 120\sum_{1 \leq i \leq j \leq k \leq \ell \leq m \leq n} \tilde f_{ijk \ell m} \lambda_i\lambda_j\lambda_k\lambda_\ell \lambda_m,\]</p><p>where <span>$\tilde f_{iiiii} = f_{iiiii}/5! = f_{iiiii}/120$</span>, <span>$\tilde f_{iiiij} = f_{iiiij}/24$</span>, <span>$\tilde f_{iijjj} = f_{iijjj}/12$</span>, <span>$\tilde f_{iijjk} = f_{iijjk}/4$</span>, <span>$\tilde f_{iijk\ell} = f_{iijk\ell}/2$</span>, and <span>$\tilde f_{ijk\ell m} = f_{ijk\ell m}$</span>.</p><p>This interpolant has cubic precision, meaning it can recover cubic polynomials. Note that this sum has</p><p class="math-container">\[\sum_{i=1}^n\sum_{j=i}^n\sum_{k=j}^n\sum_{\ell=k}^n\sum_{m=k}^n 1 = \frac{n^5}{120} + \frac{n^4}{12} + \cdots = \mathcal O(n^5)\]</p><p>terms, which could cause issues with many natural neighbours. For example, with <span>$n = 20$</span> we have <span>$n^5 = 3,200,000$</span>. In fact, as discussed in Section 6.5 of <a href="https://kluedo.ub.rptu.de/frontdoor/deliver/index/docId/2104/file/diss.bobach.natural.neighbor.20090615.pdf">Bobach&#39;s thesis</a>, more than 150 million operations could be required with <span>$n = 20$</span>. We discuss benchmark results in the comparison section of the sidebar.</p><h1 id="Regions-of-Influence"><a class="docs-heading-anchor" href="#Regions-of-Influence">Regions of Influence</a><a id="Regions-of-Influence-1"></a><a class="docs-heading-anchor-permalink" href="#Regions-of-Influence" title="Permalink"></a></h1><p>The <em>region of influence</em> for the natural neighbour coordinates associated with a point <span>$\boldsymbol x_i$</span> is the interior the union of all circumcircles coming from the triangles of the underlying triangulation that pass through <span>$\boldsymbol x_i$</span>. We can visualise this for the coordinates we define above below. (this region of influence definition not necessarily generalise to the triangle and nearest neighbour coordinates, but we still compare them).</p><p>We take a set of data sites in <span>$[-1, 1]^2$</span> such that all function values are zero except for <span>$z_1 = 0$</span> with <span>$\boldsymbol x_1 = \boldsymbol 0$</span>. Using this setup, we obtain the following results (see also Figure 3.6 of Bobach&#39;s thesis linked previously):</p><figure>
    <img src='../figures/influence.png', alt='Region of Influence'><br>
</figure><p>We can indeed see the effect of the region of influence about this single point <span>$\boldsymbol x_1$</span>. Note also that <span>$f^{\text{SIB}1}$</span> is much smoother than the others.</p><h1 id="Extrapolation"><a class="docs-heading-anchor" href="#Extrapolation">Extrapolation</a><a id="Extrapolation-1"></a><a class="docs-heading-anchor-permalink" href="#Extrapolation" title="Permalink"></a></h1><p>An important consideration is extrapolation. Currently, all the methods above assume that the query point <span>$\boldsymbol x_0$</span> is in <span>$\mathcal C(\boldsymbol X)$</span>, and the interpolation near the boundary of <span>$\mathcal C(\boldsymbol X)$</span> often has some weird effects. There are many approaches available for extrapolation, such as with <a href="https://doi.org/10.1016/j.cad.2008.08.007">ghost points</a>, although these are not implemented in this package (yet!).</p><p>The approach we take for any point outside of <span>$\mathcal C(\boldsymbol X)$</span>, or on <span>$\partial\mathcal C(\boldsymbol X)$</span>, is to find the ghost triangle that <span>$\boldsymbol x_0$</span> is in (ghost triangles are defined <a href="https://danielvandh.github.io/DelaunayTriangulation.jl/dev/boundary_handling/#Ghost-Triangles">here</a> in the DelaunayTriangulation.jl documentation), which will have some boundary edge <span>$\boldsymbol e_{ij}$</span>. (Similarly, if <span>$\boldsymbol x_0 \in \partial \mathcal C(\boldsymbol X)$</span>, <span>$\boldsymbol e_{ij}$</span> is the boundary edge that it is on.) We then simply use two-point interpolation, letting </p><p class="math-container">\[f(\boldsymbol x_0) \approx \lambda_iz_i + \lambda_jz_j,\]</p><p>where <span>$\lambda_i = 1-t$</span>, <span>$\lambda_j = t$</span>, <span>$\ell = \|x_i - \boldsymbol x_j\|$</span>, and <span>$t = [(x_0 - x_i)(x_j - x_i) + (y_0 - y_i)(y_j - y_i)]/\ell^2$</span>. Note also that in this definition of <span>$t$</span> we have projected <span>$\boldsymbol x_0$</span> onto the line through <span>$\boldsymbol x_i$</span> and <span>$\boldsymbol x_j$</span> – this projection is not necessarily on <span>$\boldsymbol e_{ij}$</span>, though, so <span>$t$</span> will not always be in <span>$[0, 1]$</span>, meaning the coordinates are not guaranteed to be (and probably won&#39;t be) convex.</p><p>This extrapolation will not always be perfect, but it is good enough until we implement more sophisticated methods. If you want to disable this approach, just use the <code>project = false</code> keyword argument when evaluating your interpolant.</p><p>Similarly, if you have points defining a boundary of some domain that isn&#39;t necessarily convex, the function <code>identify_exterior_points</code> may be useful to you, provided you have represented your boundary as defined <a href="https://danielvandh.github.io/DelaunayTriangulation.jl/dev/boundary_handling/#Boundary-Specification">here in DelaunayTriangulation.jl</a>. See the Switzerland example in the sidebar for more information.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../compare/">« Comparison of Interpolation Methods</a><a class="docs-footer-nextpage" href="../differentiation_math/">Differentiation Details »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 30 May 2023 12:50">Tuesday 30 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
