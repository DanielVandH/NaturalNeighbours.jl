var documenterSearchIndex = {"docs":
[{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"CurrentModule = NaturalNeighbours","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"In this section, we give some of the mathematical background behind natural neighbour interpolation, and other interpolation methods provided from this package. The discussion here will be limited, but you can see this thesis or this Wikipedia article for more information. The discussion that follows is primarily sourced from the linked thesis.","category":"page"},{"location":"interpolation_math/#Voronoi-Tessellation","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"","category":"section"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"We need to first define the Voronoi tessellation. We consider some set of points boldsymbol X = boldsymbol x_1 ldots boldsymbol x_m subseteq mathbb R^2. The Voronoi tessellation of boldsymbol X, denoted mathcal V(boldsymbol X), is a set of convex polygons V_boldsymbol x_1 ldots V_boldsymbol x_m, also called tiles, such that ","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"$","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"V{\\boldsymbol xi} = {\\boldsymbol x \\in \\mathbb R^2 : \\|\\boldsymbol x - \\boldsymbol xi\\| \\leq \\|\\boldsymbol x - \\boldsymbol xj\\|,~ \\boldsymbol x_j \\in \\boldsymbol X}. $","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"In particular, any point in V_boldsymbol x_i is closer to boldsymbol x_i than it is to any other point in boldsymbol X. We will also denote V_boldsymbol x_i by V_i. DelaunayTriangulation.jl is used to build mathcal V(boldsymbol X). An example of a Voronoi tessellation is shown below.","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"<figure>\n    <img src='../figs/example_tessellation.png', alt='Voronoi Tessellation'><br>\n</figure>","category":"page"},{"location":"interpolation_math/#Natural-Neighbours","page":"Voronoi Tessellation","title":"Natural Neighbours","text":"","category":"section"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"See that the tiles of the tessellation in the figure above intersect along a line, called the Voronoi facet, that we denote by mathcal F_ij = mathcal V_i cap mathcal V_j. Whenever mathcal F_ij neq emptyset, we say that boldsymbol x_i and boldsymbol x_j are natural neighbours in boldsymbol X. We denote the set of natural neighbours to a point boldsymbol x in boldsymbol X by N(boldsymbol x) subseteq boldsymbol X, and we denote the corresponding indices by N_i = j  boldsymbol x_j in N(boldsymbol x_j).","category":"page"},{"location":"interpolation_math/#Natural-Neighbour-Coordinates","page":"Voronoi Tessellation","title":"Natural Neighbour Coordinates","text":"","category":"section"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"We represent points locally using what are known as natural neighbour coordinates, which are based on the nearby Voronoi tiles. In particular, we make the following definition: Any set of convex coordinates boldsymbol lambda (convex means that lambda_i geq 0 for each i) of boldsymbol x with respect to the natural neighbours N(boldsymbol x) of boldsymbol x that satisfies: ","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"lambda_i  0 iff boldsymbol x_i in N(boldsymbol x),\nboldsymbol lambda is continuous with respect to boldsymbol x, ","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"is called a set of natural neighbour coordinates of boldsymbol x in boldsymbol X, or just the natural neighbour coordinates of boldsymbol x, or the local coordinates of boldsymbol x.","category":"page"},{"location":"interpolation_math/#Natural-Neighbour-Interpolation","page":"Voronoi Tessellation","title":"Natural Neighbour Interpolation","text":"","category":"section"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"Now that we have some definitions, we can actually define the steps involved in natural neighbour interpolation. We are supposing that we have some data (boldsymbol x_i z_i) for i=1ldotsm, and we want to interpolate this data at some point boldsymbol x_0 in mathcal C(boldsymbol X), where boldsymbol X is the point set (boldsymbol x_1ldotsboldsymbol x_m) and mathcal C(boldsymbol X) is the convex hull of boldsymbol x. We let Z denote the function values (z_1ldotsz_m).","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"The steps are relatively straight forward.","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"First, compute local coordinates boldsymbol lambda(boldsymbol x_0) with respect to the natural neighbours N(boldsymbol x_0).\nCombine the values z_i associated with boldsymbol x_i in N(boldsymbol x) using some blending function varphi(boldsymbol lambda Z).","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"To consider the second step, note that a major motivation for working with local coordinates is the following fact: The coordinates boldsymbol lambda that we compute can be used to represent our point boldsymbol x_0 as boldsymbol x_0 = sum_i lambda_i(boldsymbol x_0)boldsymbol x_i, a property known as the local coordinates property (Sibson, 1980), or the natural neighbour coordinates property if boldsymbol lambda is convex (as we assume them to be). ","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"In particular, the coordinates boldsymbol lambda determine how much each point boldsymbol x_i in N(boldsymbol x_0) contributes to the representation of our query point boldsymbol x_0, hence the term \"natural\". So, a natural interpolant is to simply take this linear combination and replace boldsymbol x_i by z_i, giving the scattered data interpolant","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"$","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"f(\\boldsymbol x0) = \\sum{i \\in N0} \\lambdai z_i. $","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"Note that the natural neighbour coordinates property only works for points in the convex hull of boldsymbol X (otherwise boldsymbol lambda is not convex), hence the restriction boldsymbol x_0 in mathcal C(boldsymbol X).","category":"page"},{"location":"interpolation_math/#Some-Local-Coordinates","page":"Voronoi Tessellation","title":"Some Local Coordinates","text":"","category":"section"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"Let us now define all the coordinates we provide in this package.","category":"page"},{"location":"interpolation_math/#Nearest-Neighbours","page":"Voronoi Tessellation","title":"Nearest Neighbours","text":"","category":"section"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"To represent a point boldsymbol x_0, we can use what are known as nearest neighbour coordinates, which simply assigns a weight of 1 to the generator of the tile that boldsymbol x_0 is in:","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"$","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"\\lambdai^{\\text{NEAR}} = \\begin{cases} 1 & \\boldsymbol x0 \\in \\mathcal V_i, \\ 0 & \\text{otherwise}. \\end{cases} $","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"The resulting scatterd data interpolant f^textNEAR is then just ","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"$","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"f^{\\text{NEAR}}(\\boldsymbol x) = z_i,  $","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"where boldsymbol x in mathcal V_i. An example of what this interpolant looks like is given below.","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"<figure>\n    <img src='../figs/fnear_example.png', alt='Nearest Neighbour Interpolation'><br>\n</figure>","category":"page"},{"location":"interpolation_math/#Laplace-Coordinates","page":"Voronoi Tessellation","title":"Laplace Coordinates","text":"","category":"section"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"Here we introduce Laplace coordinates, also known as non-Sibsonian coordinates. To define these coordinates, let us take some tessellation mathcal V(boldsymbol X) and see what happens when we add a point into it.","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"<figure>\n    <img src='../figs/new_tile.png', alt='Tessellation with a new point'><br>\n</figure>","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"In the figure above, the tiles with the black boundaries and no fill are the tiles of the original tessellation, and we show the tile that would be created by some query point boldsymbol x_0 (the magenta point) with a blue tile. We see that the insertion of boldsymbol x_0 into the tessellation has intersected some of the other tiles, in particular it has modified only the tiles corresponding to its natural neighbours in N(\\boldsymbol x_0).","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"For a given generator boldsymbol x_i in N(boldsymbol x_0), we see that there is a corresponding blue line passing through its tile. Denote this blue line by mathcal F_0i, and let r_i = boldsymbol x_0 - boldsymbol x_i. With this definition, we define ","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"$","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"\\lambdai^{\\text{LAP}} = \\frac{1}{\\sum{j \\in N0} \\hat\\lambdaj^{\\text{LAP}}}, \\quad \\hat\\lambdai^{\\text{LAP}} = \\frac{\\ell(\\mathcal F{0i})}{r_i}, $","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"where ell(mathcal F_0i) is the length of the facet mathcal F_0i. In particular, hatlambda_i^textLAP is the ratio of the blue line inside the tile and the distance between the generator boldsymbol x_i and the query point boldsymbol x_0. These coordinates are continuous in mathcal C(boldsymbol X) with derivative discontinuities at the data sites boldsymbol X. The resulting interpolant f^textLAP inherits these properties, where ","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"$","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"f^{\\text{LAP}}(\\boldsymbol x0) = \\sum{i \\in N0} \\lambdai^{\\text{LAP}}z_i. $","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"An example of what this interpolant looks like is given below.","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"<figure>\n    <img src='../figs/flap_example.png', alt='Laplace Interpolation'><br>\n</figure>","category":"page"},{"location":"interpolation_math/#Sibson-Coordinates","page":"Voronoi Tessellation","title":"Sibson Coordinates","text":"","category":"section"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"Now we consider Sibson's coordinates. These coordinates are similar to Laplace's coordinates, except we consider the areas rather than lengths for the facets. In particular, let us return to the figure above, reprinted below for convenience:","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"<figure>\n    <img src='../figs/new_tile.png', alt='Tessellation with a new point'><br>\n</figure>","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"The idea is to consider how much area this new blue tile \"steals\" from the tiles of its natural neighbours. Based on the following identity (Sibson, 1980),","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"$","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"\\text{Area}(\\mathcal V{\\boldsymbol x0}) \\boldsymbol x = \\sum{i \\in N0} \\text{Area}(\\mathcal V{\\boldsymbol x} \\cap \\mathcal V{\\boldsymbol xi}^{\\boldsymbol x0}), $","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"where mathcal V_boldsymbol x_0 is the new tile shown in blue, and mathcal V_boldsymbol x_i^boldsymbol x_0 is the tile associated with boldsymbol x_i in the original tessellation, i.e. prior to the insertion of boldsymbol x_0, we define Sibson's coordinates as ","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"$","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"\\lambdai^{\\text{SIB}} = \\frac{1}{\\sum{j \\in N0} \\hat\\lambdaj^{\\text{SIB}}}, \\quad \\hat\\lambdai^{\\text{SIB}} = \\text{Area}(\\mathcal V{\\boldsymbol x0} \\cap \\mathcal V{\\boldsymbol xi}^{\\boldsymbol x0}). $","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"A clearer way to write this is as ","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"$","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"\\lambdai^{\\text{SIB}} = \\frac{A(\\boldsymbol xi)}{A(\\boldsymbol x)}, $","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"where A(boldsymbol x_i) is the area of the intersection between the original tile for boldsymbol x_i and the new tile at boldsymbol x_0, and A(boldsymbol x) is the total area of the new blue tile. These coordinates are C^1 continuous in mathcal C(boldsymbol X) setminus boldsymbol X, with derivative discontinuities at the data sites, and so too is the interpolant ","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"$","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"f^{\\text{SIB}}(\\boldsymbol x0) = \\sum{i \\in N0} \\lambdai^{\\text{SIB}}z_i. $","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"We may also use f^textSIB0 and lambda_i^textSIB0 rather than f^textSIB and lambda_i^textSIB, respectively. ","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"An example of what this interpolant looks like is given below.","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"<figure>\n    <img src='../figs/fsib0_example.png', alt='Sibson Interpolation'><br>\n</figure>","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"Our implementation of these coordinates follows this article with some simple modifications.","category":"page"},{"location":"interpolation_math/#Sibson-1-Coordinates","page":"Voronoi Tessellation","title":"Sibson-1 Coordinates","text":"","category":"section"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"Here we describe an extension of Sibson's coordinates, which we may also call Sibson-0 coordinates, which is C^1 at the data sites (but still C^1 in mathcal C(boldsymbol X) setminus boldsymbol X). A limitation of it is that it requires an estimate of the gradient boldsymbol nabla_i at the data sites boldsymbol x_i, which may be estimated using the derivative generation techniques describd in the sidebar. ","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"To define the interpolant for these new coordinates, denoted f^textSIB1, we first define:","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"\\begin{align} ri &= \\|\\boldsymbol x0-\\boldsymbol xi\\|, \\\n\\gammai &= \\frac{\\lambdai^{\\text{SIB}0}}{ri}, \\\n\\zetai &= zi + (\\boldsymbol x0 - \\boldsymbol xi)^T\\boldsymbol\\nablai, \\\n\\zeta &= \\frac{\\sum{i\\in N0} \\gammai\\zetai}{\\sum{i\\in N0} \\gammai}, \\\n\\alpha &= \\frac{\\sum{i \\in N0} \\lambdai^{\\text{SIB}0}ri}{\\sum{i \\in N0} \\gammai}, \\\n\\beta &= \\sum{i \\in N0} \\lambdai^{\\text{SIB}0}r_i^2. \\end{align}","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"Our interpolant is then defined by ","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"$","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"f^{\\text{SIB}1}(\\boldsymbol x_0) = \\frac{\\alpha f^{\\text{SIB}0} + \\beta\\zeta}{\\alpha + \\beta}. $","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"This interpolant exactly reproduces spherical quadratics boldsymbol x mapsto mu(boldsymbol x - boldsymbol a)^T(boldsymbol x - boldsymbol a).","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"An example of what this interpolant looks like is given below.","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"<figure>\n    <img src='../figs/fsib1_example.png', alt='Sibson-1 Interpolation'><br>\n</figure>","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"Notice that the peak of the function is much smoother than it was in the other interpolant examples.","category":"page"},{"location":"interpolation_math/#Triangle-Coordinates","page":"Voronoi Tessellation","title":"Triangle Coordinates","text":"","category":"section"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"Now we define triangle coordinates. These are not actually natural coordinates (they are not continuous in vb x), but they just give a nice comparison with other methods. The idea is to interpolate based on the barycentric coordinates of the triangle that the query point is in, giving rise to a piecewise linear interpolant over mathcal C(vb X).","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"Let us take our query point vb x=(xy) and suppose it is in some triangle V with coordinates vb x_1 = (x_1y_1), vb x_2 = (x_2y_2), and vb x_3=(x_3y_3). We can then define:","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"\\begin{align} \\Delta &= (y2-y3)(x1-x3)+(x3-x2)(y1-y3), \\\n\\lambda1 &= \\frac{(y2-y3)(x-x3)+(x3-x2)(y-y3)}{\\Delta}, \\\n\\lambda2 &= \\frac{(y3-y1)(x-x3) + (x1-x3)(y-y3)}{\\Delta}, \\\n\\lambda3 &= 1-\\lambda1-\\lambda_2. \\end{align}","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"With these definitions, our interpolant is ","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"$","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"f^{\\text{TRI}}(\\boldsymbol x) = \\lambda1z1 + \\lambda2z2 + \\lambda3z3. $","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"(Of course, the subscripts would have to be modified to match the actual indices of the points rather than assuming them to be vb x_1, vb x_2, and vb x_3.) This is the same interpolant used in FiniteVolumeMethod.jl.","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"An example of what this interpolant looks like is given below.","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"<figure>\n    <img src='../figs/tri_example.png', alt='Triangle Interpolation'><br>\n</figure>","category":"page"},{"location":"interpolation_math/#Extrapolation","page":"Voronoi Tessellation","title":"Extrapolation","text":"","category":"section"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"An important consideration is extrapolation. Currently, all the methods above assume that the query point vb x_0 is in mathcal C(vb X), and the interpolation near the boundary of mathcal C(vb X) often has some weird effects. There are many approaches available for extrapolation, such as with ghost points, although these are not implemented in this package (yet!).","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"The approach we take for any point outside of mathcal C(vb X), or on partialmathcal C(vb X), is to find the ghost triangle that vb x_0 is in (ghost triangles are defined here in the DelaunayTriangulation.jl documentation), which will have some boundary edge vb e_ij. (Similarly, if vb x_0 in partial mathcal C(vb X), vb e_ij is the boundary edge that it is on.) We then simply use two-point interpolation, letting ","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"$","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"f(\\vb x0) \\approx \\lambdaizi + \\lambdajz_j, $","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"where lambda_i = 1-t, lambda_j = t, ell = x_i - vb x_j, and t = (x_0 - x_i)(x_j - x_i) + (y_0 - y_i)(y_j - y_i)ell^2. Note also that in this definition of t we have projected vb x_0 onto the line through vb x_i and vb x_j – this projection is not necessarily on vb e_ij, though, so t will not always be in 0 1, meaning the coordinates are not guaranteed to be (and probably won't be) convex.","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"This extrapolation will not always be perfect, but it is good enough until we implement more sophisticated methods. If you want to disable this approach, just use the project = false keyword argument when evaluating your interpolant.","category":"page"},{"location":"interpolation_math/","page":"Voronoi Tessellation","title":"Voronoi Tessellation","text":"Similarly, if you have points defining a boundary of some domain that isn't necessarily convex, the function identify_exterior_points may be useful to you, provided you have represented your boundary as defined here in DelaunayTriangulation.jl. See the Switzerland example in the sidebar for more information.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = NaturalNeighbours","category":"page"},{"location":"#NaturalNeighbours","page":"Home","title":"NaturalNeighbours","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for NaturalNeighbours.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is a package for working with natural neighbours of planar point sets, enabling scattered data (or spatial) interpolation via natural neighbour interpolation, as well as derivative generation. We use DelaunayTriangulation.jl to define the spatial information. Much of the work in this package is based on this great thesis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please see the sections in the sidebar for some more discussion.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [NaturalNeighbours]","category":"page"},{"location":"#NaturalNeighbours.AbstractDifferentiator","page":"Home","title":"NaturalNeighbours.AbstractDifferentiator","text":"abstract type AbstractDifferentiator end\n\nAbstract type for defining the method used for differentiating an interpolant or generating derivatives at data sites. \n\nDirect(): Generate derivatives directly with one least squares problem.\nIterative(): Generate derivatives iteratively: Gradients are estimated first, and then both gradients and Hessians are estimated with the initial gradients used to refine the results.  \n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.AbstractInterpolator","page":"Home","title":"NaturalNeighbours.AbstractInterpolator","text":"abstract type AbstractInterpolator{D}\n\nAbstract type for defining the method used for evaluating an interpolant. D is, roughly, defined to be  the smoothness at the data sites (currently only relevant for Sibson). The available subtypes are:\n\nSibson(d): Interpolate via the Sibson interpolant, with C(d) continuity at the data sites. Only defined for D ∈ (0, 1). If D == 1, gradients must be provided.\nTriangle(d): Interpolate based on vertices of the triangle that the point resides in, with C(0) continuity at the data sites. D is ignored.\nNearest(d): Interpolate by returning the function value at the nearest data site. D doesn't mean much here (it could be D = ∞), and so it is ignored and replaced with 0.\nLaplace(d): Interpolate via the Laplace interpolant, with C(0) continuity at the data sites. D is ignored.\n\nOur implementation of Sibson(0)'s coordinates follows this article with some simple modifications.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Direct","page":"Home","title":"NaturalNeighbours.Direct","text":"Direct()\n\nGenerate derivatives directly with one least squares problem.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Iterative","page":"Home","title":"NaturalNeighbours.Iterative","text":"Iterative()\n\nGenerate derivatives iteratively: Gradients are estimated first, and then both gradients and Hessians are estimated with the initial gradients used to refine the results.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Laplace","page":"Home","title":"NaturalNeighbours.Laplace","text":"Laplace()\n\nInterpolate using Laplace's coordinates.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Nearest","page":"Home","title":"NaturalNeighbours.Nearest","text":"Nearest()\n\nInterpolate by taking the function value at the nearest data site.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Sibson","page":"Home","title":"NaturalNeighbours.Sibson","text":"Sibson(d=0)\n\nInterpolate using Sibson's coordinates with C(d) continuity at the data sites.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Triangle","page":"Home","title":"NaturalNeighbours.Triangle","text":"Triangle()\n\nInterpolate using a piecewise linear interpolant over the underlying triangulation.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.differentiate-Tuple{NaturalNeighbours.NaturalNeighboursInterpolant, Any}","page":"Home","title":"NaturalNeighbours.differentiate","text":"differentiate(itp::NaturalNeighboursInterpolant, order)\n\nDifferentiate a given interpolant itp up to degree order (1 or 2). The returned object is a  NaturalNeighboursDifferentiator struct, which is callable. \n\nFor calling the resulting struct, we define the following methods:\n\n(∂::NaturalNeighboursDifferentiator)(x, y, zᵢ, nc, id::Integer=1; parallel=false, method=default_diff_method(∂), kwargs...)\n(∂::NaturalNeighboursDifferentiator)(x, y, id::Integer=1; parallel=false, method=default_diff_method(∂), interpolant_method=Sibson(), rng=Random.default_rng(), project = true, kwargs...)\n(∂::NaturalNeighboursDifferentiator)(vals::AbstractVector, x::AbstractVector, y::AbstractVector; parallel=true, method=default_diff_method(∂), interpolant_method=Sibson(), kwargs...)\n(∂::NaturalNeighboursDifferentiator{I, O})(x::AbstractVector, y::AbstractVector; parallel=true, method=default_diff_method(∂), interpolant_method=Sibson(), kwargs...) where {I, O}\n\nThis method is useful if you already have an estimate for the function value, zᵢ, at the data site, (x, y), provided you also provide the NaturalCoordinates nc. id is the thread id.\nThis method is for scalars, with id referring to a thread id.\nThis method is an in-place method for vectors, storing ∂(x[i], y[i], 1) into vals[i].\nThis method is similar to (3), but vals is constructed and returned.\n\nThe available keyword arguments are:\n\nparallel=true: Whether to use multithreading. Ignored for the first two methods. \nmethod=default_diff_method(∂): Default method for evaluating the interpolant. default_diff_method(∂) returns Direct() if the underlying interpolant has no gradients, and Iterative() otherwise. The method must be a AbstractDifferentiator.\ninterpolant_method=Sibson(): The method used for evaluating the interpolant to estimate zᵢ for the latter three methods. See AbstractInterpolator for the avaiable methods.\nrng=Random.default_rng(): The random number generator used for estimating zᵢ for the latter three methods, or for constructing the natural coordinates.\nproject=false: Whether to project any extrapolated points onto the boundary of the convex hull of the data sites and perform two-point interpolation, or to simply replace any extrapolated values with NaN, when evaluating the interpolant in the latter three methods.\nuse_cubic_terms=true: If estimating second order derivatives, whether to use cubic terms. Only relevant for method == Direct().\nalpha=0.1: If estimating second order derivatives, the weighting parameter used for estimating the second order derivatives. Only relevant for method == Iterative().\nuse_sibson_weight=true: Whether to weight the residuals in the associated least squares problems by the associated Sibson coordinates. Only relevant for method == Iterative() if order == 2.\n\nThe outputs are:\n\norder == 1: The scalar methods return a Tuple of the form (∂x, ∂y), while the vector methods return a vector of Tuples of the form (∂x, ∂y).\norder == 2: The scalar methods return a (∇, ℋ), where ∇ is a Tuple of the form (∂x, ∂y) and ℋ is a Tuple of the form (∂xx, ∂yy, ∂xy). The vector methods return a vector of (∇, ℋ)s.\n\n\n\n\n\n","category":"method"},{"location":"#NaturalNeighbours.generate_derivatives","page":"Home","title":"NaturalNeighbours.generate_derivatives","text":"generate_derivatives(\n    tri,\n    z,\n    derivative_caches=[DerivativeCache(tri) for _ in 1:Base.Threads.nthreads()],\n    neighbour_caches=[NaturalNeighboursCache(tri) for _ in 1:Base.Threads.nthreads()];\n    parallel=true,\n    method=Direct(),\n    use_cubic_terms=true,\n    alpha=0.1,\n    initial_gradients=dwrap(method) == Direct() ? nothing : generate_gradients(tri, z, derivative_caches, neighbour_caches; method=dwrap(method), parallel, rng)\n)\n\nGenerate derivatives at the data sites defined by the triangulation tri with associated function values tri.\n\nArguments\n\ntri: A Triangulation object.\nz: A vector of function values at the data sites.\nderivative_caches=[DerivativeCache(tri) for _ in 1:Base.Threads.nthreads()]: A vector of DerivativeCache objects, one for each thread.\nneighbour_caches=[NaturalNeighboursCache(tri) for _ in 1:Base.Threads.nthreads()]: A vector of NaturalNeighboursCache objects, one for each thread.\n\nKeyword Arguments\n\nparallel=true: Whether to use multithreading or not.\nmethod=Direct(): The method used for generating the derivatives. See AbstractDifferentiator.\nuse_cubic_terms=true: Whether to use cubic terms for estimating the second order derivatives. Only relevant for method == Direct().\nalpha=0.1: The weighting parameter used for estimating the second order derivatives. Only relevant for method == Iterative().\ninitial_gradients=dwrap(method) == Direct() ? nothing : generate_gradients(tri, z, derivative_caches, neighbour_caches; method=dwrap(method), parallel): The initial gradients used for estimating the second order derivatives. Only relevant for method == Iterative().\n\nOutput\n\n∇: A vector of gradients at the data sites. Each element is a Tuple defining the gradient entries.\nℋ: A vector of Hessians at the data sites. Each element is a Tuple defining the Hessian entries in the form (H[1, 1], H[2, 2], H[1, 2]) (H[2, 1] is the same as H[2, 2]).\n\n\n\n\n\n","category":"function"},{"location":"#NaturalNeighbours.generate_gradients","page":"Home","title":"NaturalNeighbours.generate_gradients","text":"generate_gradients(\n    tri,\n    z,\n    derivative_caches=[DerivativeCache(tri) for _ in 1:Base.Threads.nthreads()],\n    neighbour_caches=[NaturalNeighboursCache(tri) for _ in 1:Base.Threads.nthreads()];\n    parallel=true\n)\n\nGenerate gradients at the data sites defined by the triangulation tri with associated function values tri.\n\nArguments\n\ntri: A Triangulation object.\nz: A vector of function values at the data sites.\nderivative_caches=[DerivativeCache(tri) for _ in 1:Base.Threads.nthreads()]: A vector of DerivativeCache objects, one for each thread.\nneighbour_caches=[NaturalNeighboursCache(tri) for _ in 1:Base.Threads.nthreads()]: A vector of NaturalNeighboursCache objects, one for each thread.\n\nKeyword Arguments\n\nparallel=true: Whether to use multithreading or not.\n\nOutput\n\n∇: A vector of gradients at the data sites. Each element is a Tuple defining the gradient entries.\n\n\n\n\n\n","category":"function"},{"location":"#NaturalNeighbours.identify_exterior_points-NTuple{4, Any}","page":"Home","title":"NaturalNeighbours.identify_exterior_points","text":"identify_exterior_points(x, y, points, boundary_nodes)\n\nGiven a polygon described by (points, boundary_nodes), matching the  specification of polygons in DelaunayTriangulation.jl (see here), returns a vector of indices of the points defined by (x, y) that are outside of the polygon.\n\n\n\n\n\n","category":"method"},{"location":"#NaturalNeighbours.interpolate-Tuple{DelaunayTriangulation.Triangulation, Any}","page":"Home","title":"NaturalNeighbours.interpolate","text":"interpolate(tri::Triangulation, z; gradient=nothing, hessian=nothing, derivatives=false, kwargs...)\ninterpolate(points, z; gradient=nothing, hessian=nothing, derivatives=false, kwargs...)\ninterpolate(x::AbstractVector, y::AbstractVector, z; gradient=nothing, hessian=nothing, derivatives=false, kwargs...)\n\nConstruct an interpolant over the data z at the sites defined by the triangulation tri (or points, or (x, y)). See the Output  section for a description of how to use the interpolant itp.\n\nKeyword Arguments\n\ngradient=nothing: The gradients at the corresponding data sites of z. Will be generated if isnothing(gradient) and derivatives==true.\nhessian=nothing: The hessians at the corresponding data sites of z. Will be generated if isnothing(hessian) and derivatives==true.\nderivatives=false: Whether to generate derivatives at the data sites of z. See also generate_derivatives.\nkwargs...: Keyword arguments passed to generate_derivatives.\n\nOutput\n\nThe returned value is a NaturalNeighboursInterpolant struct. This struct is callable, with the following methods defined:\n\n(itp::NaturalNeighboursInterpolant)(x, y, id::Integer=1; parallel=false, method=Sibson(), project = true, kwargs...)\n(itp::NaturalNeighboursInterpolant)(vals::AbstractVector, x::AbstractVector, y::AbstractVector; parallel=true, method=Sibson(), project = true, kwargs...)\n(itp::NaturalNeighboursInterpolant)(x::AbstractVector, y::AbstractVector; parallel=true, method=Sibson(), project = true, kwargs...)\n\nThe first method is for scalars, with id referring to a thread id. \nThis method is an in-place method for vectors, storing itp(x[i], y[i]) into vals[i]. \nThis method is similar to (2), but vals is constructed and returned. \n\nIn each method, method defines the method used for evaluating the interpolant, which is some AbstractInterpolator. For the first  method, parallel is ignored, but for the latter two methods it defines whether to use multithreading or not for evaluating the interpolant at  all the points. The kwargs... argument is passed into add_point! from DelaunayTriangulation.jl, e.g. you could pass some rng. Lastly,  the project argument determines whether extrapolation is performed by projecting any exterior points onto the boundary of the convex hull  of the data sites and performing two-point interpolation, or to simply replaced any extrapolated values with NaN.\n\n\n\n\n\n","category":"method"}]
}
