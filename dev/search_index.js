var documenterSearchIndex = {"docs":
[{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"CurrentModule = NaturalNeighbours","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"In this section, we give some of the mathematical detail used for implementing derivative generation, following this thesis. The discussion that follows is primarily sourced from Chapter 6 of the linked thesis. While it is possible to generate derivatives of arbitary order, our discussion here in this section will be limited to gradient and Hessian generation.  These ideas are implemented by the generate_gradients and generate_derivatives functions, which you should use via the differentiate function.","category":"page"},{"location":"differentiation_math/#Generation-at-Data-Sites","page":"Differentiation","title":"Generation at Data Sites","text":"","category":"section"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"Let us first consider generating derivatives at the data points used to define the interpolant, (boldsymbol x_1 z_1) ldots (boldsymbol x_n z_n). We consider generating the derivatives at a data site boldsymbol x_0, where boldsymbol x_0 is some point in (boldsymbol x_1ldotsboldsymbol x_n) so that we also know z_0.","category":"page"},{"location":"differentiation_math/#Direct-Generation","page":"Differentiation","title":"Direct Generation","text":"","category":"section"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"Let us consider a direct approach first. In this approach, we generate gradients and Hessians jointly. We approximate the underlying function f by a Taylor series expansion,","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"tilde f(boldsymbol x) = z_0 + tilde f_1(boldsymbol x) + tilde f_2(boldsymbol x) + tilde f_3(boldsymbol x)","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"where ","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"beginalign*\ntilde f_1(boldsymbol x) = fracpartial f(boldsymbol x_0)partial x(x-x_0) + fracpartial f(boldsymbol x_0)partial y(y - y_0) \ntilde f_2(boldsymbol x) = frac12fracpartial^2 f(boldsymbol x_0)partial x^2(x - x_0)^2 + frac12partial^2 f(boldsymbol x_0)partial y^2(y - y_0)^2 + fracpartial^2 f(boldsymbol x_0)partial xpartial y(x-x_0)(y-y_0) \ntilde f_3(boldsymbol x) = frac16fracpartial^3 f(boldsymbol x_0)partial x^3(x-x_0)^3 + frac16fracpartial^3 f(boldsymbol x_0)partial y^3(y-y_0)^3 + frac12fracpartial^3 f(boldsymbol x_0)partial x^2partial y(x-x_0)^2(y-y_0) + frac12fracpartial^3 f(boldsymbol x_0)partial xpartial y^2(x-x_0)(y-y_0)^2\nendalign*","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"For gradient generation only, we need only take up to tilde f_1, but for Hessian generation we could include up to tilde f_2 or up to tilde f_3. Whatever option we choose, the neighbourhood that we use for approximating the derivatives needs to be chosen to match the order of the approximation.","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"To choose the neighbourhood, define the d-times iterated neighbourhood of boldsymbol x_0 by ","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"N_0^d = bigcup_i in N_0^d-1 N_i setminus 0 quad N_0^1 = N_0","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"Here, the neighbourhoods are the Delaunay neighbourhoods, not the natural neighbours – for points boldsymbol x_0 that are not one of the existing data sites, natural neighbours are used instead.","category":"page"},{"location":"differentiation_math/#Gradients","page":"Differentiation","title":"Gradients","text":"","category":"section"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"Let's now use the notation defined above to define how gradients are generated in generate_derivatives, without having to estimate Hessians at the same time. The neighbourhood we use is N_0^1, and we take tilde f = z_0 + tilde f_1. We define the following weighted least squares problem for the estimates beta_x, beta_y of partial f(boldsymbol x_0)partial x and partial f(boldsymbol x_0)partial y, respectively:","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"(beta_x beta_y) = textargmin_(beta_x beta_y) sum_i in mathcal N_0^1 W_i left(tilde z_i - beta_1tilde x_i - beta_2tilde y_iright)^2","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"where W_i = 1boldsymbol x_i - boldsymbol x_i^2, tilde z_i = z_i-z_0, tilde x_i=x_i-x_0, and tilde y_i = y_i-y_0. This weighted least squares problem is solved by solving the associated linear system tildeboldsymbol Xboldsymbolbeta = tildeboldsymbol z, where tildeboldsymbol X in mathbb R^m times 2 is defined by (tildeboldsymbol X)_i1 = beta_i(x_i - x_0) and (tildeboldsymbol X)_i2 = beta_i(y_i - y_0), boldsymbolbeta = (beta_1beta_2)^T, and tildeboldsymbol z = (tilde z_1ldotstilde z_m)^T.","category":"page"},{"location":"differentiation_math/#Joint-Gradients-and-Hessians","page":"Differentiation","title":"Joint Gradients and Hessians","text":"","category":"section"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"Hessians can similarly be estimated, although currently they must be estimated jointly with gradients. We take tilde f = z_0 + tilde f_1 + tilde f_2 in the following discussion, although taking up to tilde f_3 has an obvious extension. (The reason to also allow for estimating up to the cubic terms is because sometimes it provides better estimates for the Hessians than only going up to the quadratic terms – see the examples in Chapter 6 here.) ","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"Defining beta_1 = partial f(boldsymbol x_0)partial x, beta_2 = partial f(boldsymbol x_0)partial y, beta_3 = partial^2 f(boldsymbol x_0)partial x^2, beta_4 = partial^2 f(boldsymbol x_0)partial y^2, and beta_5 = partial^2 f(boldsymbol x_0)partial xpartial y, we have the following weighted least squares problem with boldsymbolbeta=(beta_1beta_2beta_3beta_4beta_5)^T:","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"boldsymbolbeta = textargmin_boldsymbolbeta sum_i in N_0^2 W_ileft(tilde z_i - beta_1tilde x_i - beta_2tilde y_i - frac12beta_3tilde x_i^2 - frac12beta_4tilde y_i^2 - beta_5tilde x_itilde y_iright)^2","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"using similar notation as in the gradient case. (In the cubic case, use N_0^3 and go up to beta_9, discarding beta_6ldotsbeta_9 at the end.) The associated linear system in this case has matrix tildeboldsymbol X in mathbb R^m times 2 (m = N_0^2) defined by (tildeboldsymbol X)_i1 = beta_itilde x_i, (tildeboldsymbol X)_i2 = beta_itilde y_i, (tildeboldsymbol X)_i3 = beta_itilde x_i^2, (tildeboldsymbol X)_i4 = beta_itilde y_i^2, and (tildeboldsymbol X)_i5 = beta_itilde x_itilde y_i.","category":"page"},{"location":"differentiation_math/#Iterative-Generation","page":"Differentiation","title":"Iterative Generation","text":"","category":"section"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"Now we discuss iterative generation. Here, we suppose that we have already estimated gradients at all of the data sites boldsymbol x_i neighbouring boldsymbol x_0 using the direct approach. To help with the notation, we will let boldsymbol g_i^1 denote our initial estimate of the gradient at a point boldsymbol x_i, and the gradient and Hessian that we are now estimating at boldsymbol x_0 are given by boldsymbol g_0^2 and boldsymbol H_0^2, respectively.","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"We define the following loss function, where beta_i = 1boldsymbol x_i-boldsymbol x_0 and alpha in (0 1):","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"beginalign*\nmathcal L(boldsymbol g_0^2 boldsymbol H_0^2) = sum_i in mathcal N_0 W_ileftalpha mathcal L_1^i(boldsymbol g_0^2 boldsymbol H_0^2)^2 + (1-alpha)L_2^i(boldsymbol g_0^2 boldsymbol H_0^2)^2right \nmathcal L_1^i(boldsymbol g_0^2 boldsymbol H_0^2)^2 = leftfrac12(boldsymbol x_i-boldsymbol x_0)^Tboldsymbol H_0^2(boldsymbol x_i - boldsymbol x_0) + (boldsymbol x_i-boldsymbol x_0)^Tboldsymbol g_0^2 + z_0-z_iright^2 \nmathcal L_2^i(boldsymbol g_0^2 boldsymbol H_0^2) = leftboldsymbol H_0^2 boldsymbol x_i + boldsymbol g_062 - boldsymbol g_i^1right^2\nendalign*","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"This objective function combines the losses between tilde f(boldsymbol x_i) and z_i, and between boldsymbol nabla tilde f(boldsymbol x_i) and boldsymbol g_i^1, weighting them by some parameter alpha in (0 1) (typically alpha approx 01 is a reasonable default). After some basic algebra and calculus,  it is possible to show that minimising mathcal L is the same as solving ","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"overlineboldsymbol A^Toverlineboldsymbol w + overlineboldsymbol B^Toverlineboldsymbol g_1 + overlineboldsymbol C^Toverlineboldsymbol g_2 = left(overlineboldsymbol A^Toverlineboldsymbol A + overlineboldsymbol B^Toverlineboldsymbol B + overlineboldsymbol C^Toverlineboldsymbol Cright)boldsymbol theta","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"where we define:","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"beginalign*\ntilde z_i = z_i - z_0 \nW_i = frac1boldsymbol x_i-boldsymbol x_0^2\ngamma_i = sqrtfracalphaW_i \ngamma_i^prime = sqrtfrac1-alphaW_i\noverlineboldsymbol A_i = gamma_i beginbmatrix x_i-x_0  y_i-y_0  frac12(x_i-x_0)^2  frac12(y_i-y_0)^2  (x_i-x_0)(y_i-y_0) endbmatrix \noverlineboldsymbol B_i  = gamma_i^prime beginbmatrix 1  0  x_i - x_0  0  y_i - y_0 endbmatrix \noverlineboldsymbol C_i  = gamma_i^prime beginbmatrix 0  1  0  y_i-y_0  x_i-x_0 endbmatrix \noverlineboldsymbol w = gamma_i tilde z_i \noverlineboldsymbol g_1 = gamma_i^prime g_i1 \noverlineboldsymbol g_2 = gamma_i^prime g_i2 \nboldsymbolbmtheta = beginbmatrix fracpartial f(boldsymbol x_0)partial x  fracpartial f(boldsymbol x_0)partial y  fracpartial^2 f(boldsymbol x_0)partial x^2  fracpartial f(boldsymbol x_0)partial y^2  fracpartial f(boldsymbol x_0)partial xpartial y endbmatrix^T\nendalign*","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"To solve this linear system, let","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"boldsymbol D = beginbmatrix overlineboldsymbol A  overlineboldsymbol B  overlineboldsymbol C endbmatrix quad boldsymbol c = beginbmatrix overlineboldsymbol w  overlineboldsymbol g_1  overlineboldsymbol g_2 endbmatrix","category":"page"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"so that boldsymbol D^Tboldsymbol Dboldsymboltheta = boldsymbol D^Tboldsymbol c. These are just the normal equations for boldsymbol Dboldsymbol theta = boldsymbol c, thus we can estimate the gradients and Hessians by simply solving boldsymbol Dboldsymbol theta = boldsymbol c.","category":"page"},{"location":"differentiation_math/#Generation-Away-from-the-Data-Sites","page":"Differentiation","title":"Generation Away from the Data Sites","text":"","category":"section"},{"location":"differentiation_math/","page":"Differentiation","title":"Differentiation","text":"It is possible to extend these ideas so that we can approximate the derivative at any point boldsymbol x_0 in mathcal C(boldsymbol X). Using the associated interpolant, simply approximate z_0 with the value of the interpolant at boldsymbol x_0, and then replace W_i by lambda_iboldsymbol x_i-boldsymbol x_0, where lambda_i is the Sibson coordinate at boldsymbol x_i relative to boldsymbol x_0. If using a direct approach to approximate gradients and Hessians, Sibson coordinates cannot be used (because you can't extend the weights out to N_0^2) and so W_i remains as is in that case. Note that the N_0 neighbourhoods are now the sets of natural neighbours.","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"CurrentModule = NaturalNeighbours","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"In this section, we give some of the mathematical background behind natural neighbour interpolation, and other interpolation methods provided from this package. The discussion here will be limited, but you can see this thesis or this Wikipedia article for more information. The discussion that follows is primarily sourced from the linked thesis. These ideas are implemented by the interpolate function.","category":"page"},{"location":"interpolation_math/#Voronoi-Tessellation","page":"Interpolation","title":"Voronoi Tessellation","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"We need to first define the Voronoi tessellation. We consider some set of points boldsymbol X = boldsymbol x_1 ldots boldsymbol x_m subseteq mathbb R^2. The Voronoi tessellation of boldsymbol X, denoted mathcal V(boldsymbol X), is a set of convex polygons V_boldsymbol x_1 ldots V_boldsymbol x_m, also called tiles, such that ","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"beginequation*\nV_boldsymbol x_i = boldsymbol x in mathbb R^2  boldsymbol x - boldsymbol x_i leq boldsymbol x - boldsymbol x_j boldsymbol x_j in boldsymbol X\nendequation*","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"In particular, any point in V_boldsymbol x_i is closer to boldsymbol x_i than it is to any other point in boldsymbol X. We will also denote V_boldsymbol x_i by V_i. DelaunayTriangulation.jl is used to build mathcal V(boldsymbol X). An example of a Voronoi tessellation is shown below.","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"<figure>\n    <img src='../figs/example_tessellation.png', alt='Voronoi Tessellation'><br>\n</figure>","category":"page"},{"location":"interpolation_math/#Natural-Neighbours","page":"Interpolation","title":"Natural Neighbours","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"See that the tiles of the tessellation in the figure above intersect along a line, called the Voronoi facet, that we denote by mathcal F_ij = mathcal V_i cap mathcal V_j. Whenever mathcal F_ij neq emptyset, we say that boldsymbol x_i and boldsymbol x_j are natural neighbours in boldsymbol X. We denote the set of natural neighbours to a point boldsymbol x in boldsymbol X by N(boldsymbol x) subseteq boldsymbol X, and we denote the corresponding indices by N_i = j  boldsymbol x_j in N(boldsymbol x_j).","category":"page"},{"location":"interpolation_math/#Natural-Neighbour-Coordinates","page":"Interpolation","title":"Natural Neighbour Coordinates","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"We represent points locally using what are known as natural neighbour coordinates, which are based on the nearby Voronoi tiles. In particular, we make the following definition: Any set of convex coordinates boldsymbol lambda (convex means that lambda_i geq 0 for each i) of boldsymbol x with respect to the natural neighbours N(boldsymbol x) of boldsymbol x that satisfies: ","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"lambda_i  0 iff boldsymbol x_i in N(boldsymbol x),\nboldsymbol lambda is continuous with respect to boldsymbol x, ","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"is called a set of natural neighbour coordinates of boldsymbol x in boldsymbol X, or just the natural neighbour coordinates of boldsymbol x, or the local coordinates of boldsymbol x.","category":"page"},{"location":"interpolation_math/#Natural-Neighbour-Interpolation","page":"Interpolation","title":"Natural Neighbour Interpolation","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"Now that we have some definitions, we can actually define the steps involved in natural neighbour interpolation. We are supposing that we have some data (boldsymbol x_i z_i) for i=1ldotsm, and we want to interpolate this data at some point boldsymbol x_0 in mathcal C(boldsymbol X), where boldsymbol X is the point set (boldsymbol x_1ldotsboldsymbol x_m) and mathcal C(boldsymbol X) is the convex hull of boldsymbol x. We let Z denote the function values (z_1ldotsz_m).","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"The steps are relatively straight forward.","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"First, compute local coordinates boldsymbol lambda(boldsymbol x_0) with respect to the natural neighbours N(boldsymbol x_0).\nCombine the values z_i associated with boldsymbol x_i in N(boldsymbol x) using some blending function varphi(boldsymbol lambda Z).","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"To consider the second step, note that a major motivation for working with local coordinates is the following fact: The coordinates boldsymbol lambda that we compute can be used to represent our point boldsymbol x_0 as boldsymbol x_0 = sum_i in N_0 lambda_i(boldsymbol x_0)boldsymbol x_i, a property known as the local coordinates property (Sibson, 1980), or the natural neighbour coordinates property if boldsymbol lambda is convex (as we assume them to be). ","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"In particular, the coordinates boldsymbol lambda determine how much each point boldsymbol x_i in N(boldsymbol x_0) contributes to the representation of our query point boldsymbol x_0, hence the term \"natural\". So, a natural interpolant is to simply take this linear combination and replace boldsymbol x_i by z_i, giving the scattered data interpolant","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"f(boldsymbol x_0) = sum_i in N_0 lambda_i z_i","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"Note that the natural neighbour coordinates property only works for points in the convex hull of boldsymbol X (otherwise boldsymbol lambda is not convex), hence the restriction boldsymbol x_0 in mathcal C(boldsymbol X).","category":"page"},{"location":"interpolation_math/#Some-Local-Coordinates","page":"Interpolation","title":"Some Local Coordinates","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"Let us now define all the coordinates we provide in this package.","category":"page"},{"location":"interpolation_math/#Nearest-Neighbours","page":"Interpolation","title":"Nearest Neighbours","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"To represent a point boldsymbol x_0, we can use what are known as nearest neighbour coordinates, which simply assigns a weight of 1 to the generator of the tile that boldsymbol x_0 is in:","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"lambda_i^textNEAR = begincases 1  boldsymbol x_0 in mathcal V_i  0  textotherwise endcases","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"The resulting scatterd data interpolant f^textNEAR is then just ","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"f^textNEAR(boldsymbol x) = z_i ","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"where boldsymbol x in mathcal V_i. An example of what this interpolant looks like is given below.","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"<figure>\n    <img src='../figs/fnear_example.png', alt='Nearest Neighbour Interpolation'><br>\n</figure>","category":"page"},{"location":"interpolation_math/#Laplace-Coordinates","page":"Interpolation","title":"Laplace Coordinates","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"Here we introduce Laplace coordinates, also known as non-Sibsonian coordinates. To define these coordinates, let us take some tessellation mathcal V(boldsymbol X) and see what happens when we add a point into it.","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"<figure>\n    <img src='../figs/new_tile.png', alt='Tessellation with a new point'><br>\n</figure>","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"In the figure above, the tiles with the black boundaries and no fill are the tiles of the original tessellation, and we show the tile that would be created by some query point boldsymbol x_0 (the magenta point) with a blue tile. We see that the insertion of boldsymbol x_0 into the tessellation has intersected some of the other tiles, in particular it has modified only the tiles corresponding to its natural neighbours in N(\\boldsymbol x_0).","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"For a given generator boldsymbol x_i in N(boldsymbol x_0), we see that there is a corresponding blue line passing through its tile. Denote this blue line by mathcal F_0i, and let r_i = boldsymbol x_0 - boldsymbol x_i. With this definition, we define ","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"lambda_i^textLAP = frac1sum_j in N_0 hatlambda_j^textLAP quad hatlambda_i^textLAP = fracell(mathcal F_0i)r_i","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"where ell(mathcal F_0i) is the length of the facet mathcal F_0i. In particular, hatlambda_i^textLAP is the ratio of the blue line inside the tile and the distance between the generator boldsymbol x_i and the query point boldsymbol x_0. These coordinates are continuous in mathcal C(boldsymbol X) with derivative discontinuities at the data sites boldsymbol X. The resulting interpolant f^textLAP inherits these properties, where ","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"f^textLAP(boldsymbol x_0) = sum_i in N_0 lambda_i^textLAPz_i","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"An example of what this interpolant looks like is given below.","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"<figure>\n    <img src='../figs/flap_example.png', alt='Laplace Interpolation'><br>\n</figure>","category":"page"},{"location":"interpolation_math/#Sibson-Coordinates","page":"Interpolation","title":"Sibson Coordinates","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"Now we consider Sibson's coordinates. These coordinates are similar to Laplace's coordinates, except we consider the areas rather than lengths for the facets. In particular, let us return to the figure above, reprinted below for convenience:","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"<figure>\n    <img src='../figs/new_tile.png', alt='Tessellation with a new point'><br>\n</figure>","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"The idea is to consider how much area this new blue tile \"steals\" from the tiles of its natural neighbours. Based on the following identity (Sibson, 1980),","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"textArea(mathcal V_boldsymbol x_0) boldsymbol x = sum_i in N_0 textArea(mathcal V_boldsymbol x cap mathcal V_boldsymbol x_i^boldsymbol x_0)","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"where mathcal V_boldsymbol x_0 is the new tile shown in blue, and mathcal V_boldsymbol x_i^boldsymbol x_0 is the tile associated with boldsymbol x_i in the original tessellation, i.e. prior to the insertion of boldsymbol x_0, we define Sibson's coordinates as ","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"lambda_i^textSIB = frac1sum_j in N_0 hatlambda_j^textSIB quad hatlambda_i^textSIB = textArea(mathcal V_boldsymbol x_0 cap mathcal V_boldsymbol x_i^boldsymbol x_0)","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"A clearer way to write this is as ","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"lambda_i^textSIB = fracA(boldsymbol x_i)A(boldsymbol x)","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"where A(boldsymbol x_i) is the area of the intersection between the original tile for boldsymbol x_i and the new tile at boldsymbol x_0, and A(boldsymbol x) is the total area of the new blue tile. These coordinates are C^1 continuous in mathcal C(boldsymbol X) setminus boldsymbol X, with derivative discontinuities at the data sites, and so too is the interpolant ","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"f^textSIB(boldsymbol x_0) = sum_i in N_0 lambda_i^textSIBz_i","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"We may also use f^textSIB0 and lambda_i^textSIB0 rather than f^textSIB and lambda_i^textSIB, respectively. ","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"An example of what this interpolant looks like is given below.","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"<figure>\n    <img src='../figs/fsib0_example.png', alt='Sibson Interpolation'><br>\n</figure>","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"Our implementation of these coordinates follows this article with some simple modifications.","category":"page"},{"location":"interpolation_math/#Sibson-1-Coordinates","page":"Interpolation","title":"Sibson-1 Coordinates","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"Here we describe an extension of Sibson's coordinates, which we may also call Sibson-0 coordinates, which is C^1 at the data sites (but still C^1 in mathcal C(boldsymbol X) setminus boldsymbol X). A limitation of it is that it requires an estimate of the gradient boldsymbol nabla_i at the data sites boldsymbol x_i, which may be estimated using the derivative generation techniques describd in the sidebar. ","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"To define the interpolant for these new coordinates, denoted f^textSIB1, we first define:","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"beginalign*\nr_i = boldsymbol x_0-boldsymbol x_i \ngamma_i = fraclambda_i^textSIB0r_i \nzeta_i = z_i + (boldsymbol x_0 - boldsymbol x_i)^Tboldsymbolnabla_i \nzeta = fracsum_iin N_0 gamma_izeta_isum_iin N_0 gamma_i \nalpha = fracsum_i in N_0 lambda_i^textSIB0r_isum_i in N_0 gamma_i \nbeta = sum_i in N_0 lambda_i^textSIB0r_i^2\nendalign*","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"Our interpolant is then defined by ","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"f^textSIB1(boldsymbol x_0) = fracalpha f^textSIB0 + betazetaalpha + beta","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"This interpolant exactly reproduces spherical quadratics boldsymbol x mapsto mu(boldsymbol x - boldsymbol a)^T(boldsymbol x - boldsymbol a).","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"An example of what this interpolant looks like is given below.","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"<figure>\n    <img src='../figs/fsib1_example.png', alt='Sibson-1 Interpolation'><br>\n</figure>","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"Notice that the peak of the function is much smoother than it was in the other interpolant examples.","category":"page"},{"location":"interpolation_math/#Triangle-Coordinates","page":"Interpolation","title":"Triangle Coordinates","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"Now we define triangle coordinates. These are not actually natural coordinates (they are not continuous in boldsymbol x), but they just give a nice comparison with other methods. The idea is to interpolate based on the barycentric coordinates of the triangle that the query point is in, giving rise to a piecewise linear interpolant over mathcal C(boldsymbol X).","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"Let us take our query point boldsymbol x=(xy) and suppose it is in some triangle V with coordinates boldsymbol x_1 = (x_1y_1), boldsymbol x_2 = (x_2y_2), and boldsymbol x_3=(x_3y_3). We can then define:","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"beginalign*\nDelta = (y_2-y_3)(x_1-x_3)+(x_3-x_2)(y_1-y_3) \nlambda_1 = frac(y_2-y_3)(x-x_3)+(x_3-x_2)(y-y_3)Delta \nlambda_2 = frac(y_3-y_1)(x-x_3) + (x_1-x_3)(y-y_3)Delta \nlambda_3 = 1-lambda_1-lambda_2\nendalign*","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"With these definitions, our interpolant is ","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"f^textTRI(boldsymbol x) = lambda_1z_1 + lambda_2z_2 + lambda_3z_3","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"(Of course, the subscripts would have to be modified to match the actual indices of the points rather than assuming them to be boldsymbol x_1, boldsymbol x_2, and boldsymbol x_3.) This is the same interpolant used in FiniteVolumeMethod.jl.","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"An example of what this interpolant looks like is given below.","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"<figure>\n    <img src='../figs/tri_example.png', alt='Triangle Interpolation'><br>\n</figure>","category":"page"},{"location":"interpolation_math/#Extrapolation","page":"Interpolation","title":"Extrapolation","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"An important consideration is extrapolation. Currently, all the methods above assume that the query point boldsymbol x_0 is in mathcal C(boldsymbol X), and the interpolation near the boundary of mathcal C(boldsymbol X) often has some weird effects. There are many approaches available for extrapolation, such as with ghost points, although these are not implemented in this package (yet!).","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"The approach we take for any point outside of mathcal C(boldsymbol X), or on partialmathcal C(boldsymbol X), is to find the ghost triangle that boldsymbol x_0 is in (ghost triangles are defined here in the DelaunayTriangulation.jl documentation), which will have some boundary edge boldsymbol e_ij. (Similarly, if boldsymbol x_0 in partial mathcal C(boldsymbol X), boldsymbol e_ij is the boundary edge that it is on.) We then simply use two-point interpolation, letting ","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"f(boldsymbol x_0) approx lambda_iz_i + lambda_jz_j","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"where lambda_i = 1-t, lambda_j = t, ell = x_i - boldsymbol x_j, and t = (x_0 - x_i)(x_j - x_i) + (y_0 - y_i)(y_j - y_i)ell^2. Note also that in this definition of t we have projected boldsymbol x_0 onto the line through boldsymbol x_i and boldsymbol x_j – this projection is not necessarily on boldsymbol e_ij, though, so t will not always be in 0 1, meaning the coordinates are not guaranteed to be (and probably won't be) convex.","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"This extrapolation will not always be perfect, but it is good enough until we implement more sophisticated methods. If you want to disable this approach, just use the project = false keyword argument when evaluating your interpolant.","category":"page"},{"location":"interpolation_math/","page":"Interpolation","title":"Interpolation","text":"Similarly, if you have points defining a boundary of some domain that isn't necessarily convex, the function identify_exterior_points may be useful to you, provided you have represented your boundary as defined here in DelaunayTriangulation.jl. See the Switzerland example in the sidebar for more information.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = NaturalNeighbours","category":"page"},{"location":"#NaturalNeighbours","page":"Home","title":"NaturalNeighbours","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for NaturalNeighbours.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is a package for working with natural neighbours of planar point sets, enabling scattered data (or spatial) interpolation via natural neighbour interpolation, as well as derivative generation. We use DelaunayTriangulation.jl to define the spatial information. Much of the work in this package is based on this great thesis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please see the sections in the sidebar for some more discussion. The relevant docstrings for this package are shown below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"interpolate\ndifferentiate \ngenerate_gradients\ngenerate_derivatives\nAbstractInterpolator\nAbstractDifferentiator\nSibson\nLaplace\nTriangle\nNearest\nDirect\nIterative\nidentify_exterior_points","category":"page"},{"location":"#NaturalNeighbours.interpolate","page":"Home","title":"NaturalNeighbours.interpolate","text":"interpolate(tri::Triangulation, z; gradient=nothing, hessian=nothing, derivatives=false, kwargs...)\ninterpolate(points, z; gradient=nothing, hessian=nothing, derivatives=false, kwargs...)\ninterpolate(x::AbstractVector, y::AbstractVector, z; gradient=nothing, hessian=nothing, derivatives=false, kwargs...)\n\nConstruct an interpolant over the data z at the sites defined by the triangulation tri (or points, or (x, y)). See the Output  section for a description of how to use the interpolant itp.\n\nKeyword Arguments\n\ngradient=nothing: The gradients at the corresponding data sites of z. Will be generated if isnothing(gradient) and derivatives==true.\nhessian=nothing: The hessians at the corresponding data sites of z. Will be generated if isnothing(hessian) and derivatives==true.\nderivatives=false: Whether to generate derivatives at the data sites of z. See also generate_derivatives.\nkwargs...: Keyword arguments passed to generate_derivatives.\n\nOutput\n\nThe returned value is a NaturalNeighboursInterpolant struct. This struct is callable, with the following methods defined:\n\n(itp::NaturalNeighboursInterpolant)(x, y, id::Integer=1; parallel=false, method=Sibson(), project = true, kwargs...)\n(itp::NaturalNeighboursInterpolant)(vals::AbstractVector, x::AbstractVector, y::AbstractVector; parallel=true, method=Sibson(), project = true, kwargs...)\n(itp::NaturalNeighboursInterpolant)(x::AbstractVector, y::AbstractVector; parallel=true, method=Sibson(), project = true, kwargs...)\n\nThe first method is for scalars, with id referring to a thread id. \nThis method is an in-place method for vectors, storing itp(x[i], y[i]) into vals[i]. \nThis method is similar to (2), but vals is constructed and returned. \n\nIn each method, method defines the method used for evaluating the interpolant, which is some AbstractInterpolator. For the first  method, parallel is ignored, but for the latter two methods it defines whether to use multithreading or not for evaluating the interpolant at  all the points. The kwargs... argument is passed into add_point! from DelaunayTriangulation.jl, e.g. you could pass some rng. Lastly,  the project argument determines whether extrapolation is performed by projecting any exterior points onto the boundary of the convex hull  of the data sites and performing two-point interpolation, or to simply replaced any extrapolated values with NaN.\n\n\n\n\n\n","category":"function"},{"location":"#NaturalNeighbours.differentiate","page":"Home","title":"NaturalNeighbours.differentiate","text":"differentiate(itp::NaturalNeighboursInterpolant, order)\n\nDifferentiate a given interpolant itp up to degree order (1 or 2). The returned object is a  NaturalNeighboursDifferentiator struct, which is callable. \n\nFor calling the resulting struct, we define the following methods:\n\n(∂::NaturalNeighboursDifferentiator)(x, y, zᵢ, nc, id::Integer=1; parallel=false, method=default_diff_method(∂), kwargs...)\n(∂::NaturalNeighboursDifferentiator)(x, y, id::Integer=1; parallel=false, method=default_diff_method(∂), interpolant_method=Sibson(), rng=Random.default_rng(), project = true, kwargs...)\n(∂::NaturalNeighboursDifferentiator)(vals::AbstractVector, x::AbstractVector, y::AbstractVector; parallel=true, method=default_diff_method(∂), interpolant_method=Sibson(), kwargs...)\n(∂::NaturalNeighboursDifferentiator{I, O})(x::AbstractVector, y::AbstractVector; parallel=true, method=default_diff_method(∂), interpolant_method=Sibson(), kwargs...) where {I, O}\n\nThis method is useful if you already have an estimate for the function value, zᵢ, at the data site, (x, y), provided you also provide the NaturalCoordinates nc. id is the thread id.\nThis method is for scalars, with id referring to a thread id.\nThis method is an in-place method for vectors, storing ∂(x[i], y[i], 1) into vals[i].\nThis method is similar to (3), but vals is constructed and returned.\n\nThe available keyword arguments are:\n\nparallel=true: Whether to use multithreading. Ignored for the first two methods. \nmethod=default_diff_method(∂): Default method for evaluating the interpolant. default_diff_method(∂) returns Direct() if the underlying interpolant has no gradients, and Iterative() otherwise. The method must be a AbstractDifferentiator.\ninterpolant_method=Sibson(): The method used for evaluating the interpolant to estimate zᵢ for the latter three methods. See AbstractInterpolator for the avaiable methods.\nrng=Random.default_rng(): The random number generator used for estimating zᵢ for the latter three methods, or for constructing the natural coordinates.\nproject=false: Whether to project any extrapolated points onto the boundary of the convex hull of the data sites and perform two-point interpolation, or to simply replace any extrapolated values with NaN, when evaluating the interpolant in the latter three methods.\nuse_cubic_terms=true: If estimating second order derivatives, whether to use cubic terms. Only relevant for method == Direct().\nalpha=0.1: If estimating second order derivatives, the weighting parameter used for estimating the second order derivatives. Only relevant for method == Iterative().\nuse_sibson_weight=true: Whether to weight the residuals in the associated least squares problems by the associated Sibson coordinates. Only relevant for method == Iterative() if order == 2.\n\nThe outputs are:\n\norder == 1: The scalar methods return a Tuple of the form (∂x, ∂y), while the vector methods return a vector of Tuples of the form (∂x, ∂y).\norder == 2: The scalar methods return a (∇, ℋ), where ∇ is a Tuple of the form (∂x, ∂y) and ℋ is a Tuple of the form (∂xx, ∂yy, ∂xy). The vector methods return a vector of (∇, ℋ)s.\n\n\n\n\n\n","category":"function"},{"location":"#NaturalNeighbours.generate_gradients","page":"Home","title":"NaturalNeighbours.generate_gradients","text":"generate_gradients(\n    tri,\n    z,\n    derivative_caches=[DerivativeCache(tri) for _ in 1:Base.Threads.nthreads()],\n    neighbour_caches=[NaturalNeighboursCache(tri) for _ in 1:Base.Threads.nthreads()];\n    parallel=true\n)\n\nGenerate gradients at the data sites defined by the triangulation tri with associated function values tri.\n\nArguments\n\ntri: A Triangulation object.\nz: A vector of function values at the data sites.\nderivative_caches=[DerivativeCache(tri) for _ in 1:Base.Threads.nthreads()]: A vector of DerivativeCache objects, one for each thread.\nneighbour_caches=[NaturalNeighboursCache(tri) for _ in 1:Base.Threads.nthreads()]: A vector of NaturalNeighboursCache objects, one for each thread.\n\nKeyword Arguments\n\nparallel=true: Whether to use multithreading or not.\n\nOutput\n\n∇: A vector of gradients at the data sites. Each element is a Tuple defining the gradient entries.\n\n\n\n\n\n","category":"function"},{"location":"#NaturalNeighbours.generate_derivatives","page":"Home","title":"NaturalNeighbours.generate_derivatives","text":"generate_derivatives(\n    tri,\n    z,\n    derivative_caches=[DerivativeCache(tri) for _ in 1:Base.Threads.nthreads()],\n    neighbour_caches=[NaturalNeighboursCache(tri) for _ in 1:Base.Threads.nthreads()];\n    parallel=true,\n    method=Direct(),\n    use_cubic_terms=true,\n    alpha=0.1,\n    initial_gradients=dwrap(method) == Direct() ? nothing : generate_gradients(tri, z, derivative_caches, neighbour_caches; method=dwrap(method), parallel, rng)\n)\n\nGenerate derivatives at the data sites defined by the triangulation tri with associated function values tri.\n\nArguments\n\ntri: A Triangulation object.\nz: A vector of function values at the data sites.\nderivative_caches=[DerivativeCache(tri) for _ in 1:Base.Threads.nthreads()]: A vector of DerivativeCache objects, one for each thread.\nneighbour_caches=[NaturalNeighboursCache(tri) for _ in 1:Base.Threads.nthreads()]: A vector of NaturalNeighboursCache objects, one for each thread.\n\nKeyword Arguments\n\nparallel=true: Whether to use multithreading or not.\nmethod=Direct(): The method used for generating the derivatives. See AbstractDifferentiator.\nuse_cubic_terms=true: Whether to use cubic terms for estimating the second order derivatives. Only relevant for method == Direct().\nalpha=0.1: The weighting parameter used for estimating the second order derivatives. Only relevant for method == Iterative().\ninitial_gradients=dwrap(method) == Direct() ? nothing : generate_gradients(tri, z, derivative_caches, neighbour_caches; method=dwrap(method), parallel): The initial gradients used for estimating the second order derivatives. Only relevant for method == Iterative().\n\nOutput\n\n∇: A vector of gradients at the data sites. Each element is a Tuple defining the gradient entries.\nℋ: A vector of Hessians at the data sites. Each element is a Tuple defining the Hessian entries in the form (H[1, 1], H[2, 2], H[1, 2]) (H[2, 1] is the same as H[2, 2]).\n\n\n\n\n\n","category":"function"},{"location":"#NaturalNeighbours.AbstractInterpolator","page":"Home","title":"NaturalNeighbours.AbstractInterpolator","text":"abstract type AbstractInterpolator{D}\n\nAbstract type for defining the method used for evaluating an interpolant. D is, roughly, defined to be  the smoothness at the data sites (currently only relevant for Sibson). The available subtypes are:\n\nSibson(d): Interpolate via the Sibson interpolant, with C(d) continuity at the data sites. Only defined for D ∈ (0, 1). If D == 1, gradients must be provided.\nTriangle(d): Interpolate based on vertices of the triangle that the point resides in, with C(0) continuity at the data sites. D is ignored.\nNearest(d): Interpolate by returning the function value at the nearest data site. D doesn't mean much here (it could be D = ∞), and so it is ignored and replaced with 0.\nLaplace(d): Interpolate via the Laplace interpolant, with C(0) continuity at the data sites. D is ignored.\n\nOur implementation of Sibson(0)'s coordinates follows this article with some simple modifications.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.AbstractDifferentiator","page":"Home","title":"NaturalNeighbours.AbstractDifferentiator","text":"abstract type AbstractDifferentiator end\n\nAbstract type for defining the method used for differentiating an interpolant or generating derivatives at data sites. \n\nDirect(): Generate derivatives directly with one least squares problem.\nIterative(): Generate derivatives iteratively: Gradients are estimated first, and then both gradients and Hessians are estimated with the initial gradients used to refine the results.  \n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Sibson","page":"Home","title":"NaturalNeighbours.Sibson","text":"Sibson(d=0)\n\nInterpolate using Sibson's coordinates with C(d) continuity at the data sites.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Laplace","page":"Home","title":"NaturalNeighbours.Laplace","text":"Laplace()\n\nInterpolate using Laplace's coordinates.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Triangle","page":"Home","title":"NaturalNeighbours.Triangle","text":"Triangle()\n\nInterpolate using a piecewise linear interpolant over the underlying triangulation.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Nearest","page":"Home","title":"NaturalNeighbours.Nearest","text":"Nearest()\n\nInterpolate by taking the function value at the nearest data site.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Direct","page":"Home","title":"NaturalNeighbours.Direct","text":"Direct()\n\nGenerate derivatives directly with one least squares problem.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Iterative","page":"Home","title":"NaturalNeighbours.Iterative","text":"Iterative()\n\nGenerate derivatives iteratively: Gradients are estimated first, and then both gradients and Hessians are estimated with the initial gradients used to refine the results.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.identify_exterior_points","page":"Home","title":"NaturalNeighbours.identify_exterior_points","text":"identify_exterior_points(x, y, points, boundary_nodes)\n\nGiven a polygon described by (points, boundary_nodes), matching the  specification of polygons in DelaunayTriangulation.jl (see here), returns a vector of indices of the points defined by (x, y) that are outside of the polygon.\n\n\n\n\n\n","category":"function"}]
}
