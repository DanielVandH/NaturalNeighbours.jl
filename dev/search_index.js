var documenterSearchIndex = {"docs":
[{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"CurrentModule = NaturalNeighbours","category":"page"},{"location":"compare/#Comparison-of-Interpolation-Methods","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"","category":"section"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"In this section, we will compare the methods available in this package for interpolation. We consider both quantitative and qualitative comparisons. We first make compares using errors around each point (local analysis), and later we compare errors using global metrics (global analysis). Note that there are many papers that compare interpolation methods, so if you really want a formal analysis that also considers other interpolation methods (like kriging or radial basis methods), you can search for them. The purpose here is to just show comparisons between the methods in this package, not to, say, argue that natural neighbour interpolation fits every possible situation, or to suggest that this is even the best way to perform such an analysis. You can find some good references in Bobach's thesis. A conclusion is given at the end of this section.","category":"page"},{"location":"compare/#Setting-up-the-Analysis","page":"Comparison of Interpolation Methods","title":"Setting up the Analysis","text":"","category":"section"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"To setup this analysis, we use the following packages:","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"using NaturalNeighbours\nusing CairoMakie\nusing StableRNGs\nusing DelaunayTriangulation\nusing StaticArrays\nusing LinearAlgebra\nusing DataFrames\nusing StatsBase\nusing AlgebraOfGraphics\nusing BenchmarkTools\nconst NNI = NaturalNeighbours","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"We also define the following constants and other useful variables:","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"const itp_methods = (\n    Sibson(0),\n    Triangle(),\n    Nearest(),\n    Laplace(),\n    Sibson(1),\n    Farin(1),\n    Hiyoshi(2)\n)\nconst diff_methods = (\n    Direct(),\n    Iterative()\n)\nconst itp_aliases = (:Sibson0, :Triangle, :Nearest, :Laplace, :Sibson1, :Farin, :Hiyoshi)\nconst diff_aliases = (:Direct, :Iterative)\nconst itp_alias_map = Dict(itp_methods .=> itp_aliases)\nconst diff_alias_map = Dict(diff_methods .=> diff_aliases)\nconst colors = Dict(itp_aliases .=> [:red, :blue, :green, :orange, :purple, :black, :brown])\nconst linestyles = Dict(diff_aliases .=> [:solid, :dashdotdot])\nconst line_elements = [\n    LineElement(color=color,\n        linewidth=22,\n        linestyle=:solid) for color in values(colors)\n]\nconst style_elements = [\n    LineElement(color=:black,\n        linewidth=22,\n        linestyle=linestyle) for linestyle in values(linestyles)\n]\nconst azimuths = [0.3, 0.8, 0.3, 0.6, 0.6, 0.6, 0.45]\nrng = StableRNG(123)\nxg = LinRange(0, 1, 25)\nyg = LinRange(0, 1, 25)\nx = vec([x for x in xg, _ in yg])\ny = vec([y for _ in xg, y in yg])\nxg2 = LinRange(0, 1, 250)\nyg2 = LinRange(0, 1, 250)\nxq = vec([x for x in xg2, _ in yg2])\nyq = vec([y for _ in xg2, y in yg2])\ntol = 1e-2\ntri = triangulate([x'; y']; rng=rng)\ntriq = triangulate([xq'; yq']; rng=rng)\nexterior_idx = identify_exterior_points(xq, yq, get_points(tri), get_convex_hull_indices(tri); tol=tol)\ninterior_idx = filter(∉(exterior_idx), eachindex(xq, yq))","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"Lastly, we define the following test functions (the first six come from this report).","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"const f = [\n    (x, y) -> 0.75 * exp(-((9 * x - 2)^2 + (9 * y - 2)^2) / 4) + 0.75 * exp(-(9 * x + 1)^2 / 49 - (9 * y + 1) / 10) + 0.5 * exp(-((9 * x - 7)^2 + (9 * y - 3)^2) / 4) - 0.2 * exp(-(9 * x - 4)^2 - (9 * y - 7)^2)\n    (x, y) -> (1 / 9) * (tanh(9 * y - 9 * x) + 1)\n    (x, y) -> (1.25 + cos(5.4 * y)) / (6 * (1 + (3 * x - 1)^2))\n    (x, y) -> (1 / 3) * exp(-(81 / 16) * ((x - 1 / 2)^2 + (y - 1 / 2)^2))\n    (x, y) -> (1 / 3) * exp(-(81 / 4) * ((x - 1 / 2)^2 + (y - 1 / 2)^2))\n    (x, y) -> (1 / 9) * (64 - 81 * ((x - 1 / 2)^2 + (y - 1 / 2)^2))^(1 / 2) - 1 / 2\n    (x, y) -> sin(27 * x * y) - exp(-(x - y)^2 / 4) * cos(13 * x - 13 * y)\n]\nconst ∇f = [\n    (x, y) -> @SVector[(exp(-(9 * x - 4)^2 - (9 * y - 7)^2) * (162 * x - 72)) / 5 - (3 * exp(-(9 * x - 2)^2 / 4 - (9 * y - 2)^2 / 4) * ((81 * x) / 2 - 9)) / 4 - (exp(-(9 * x - 7)^2 / 4 - (9 * y - 3)^2 / 4) * ((81 * x) / 2 - 63 / 2)) / 2 - (3 * exp(-(9 * y) / 10 - (9 * x + 1)^2 / 49 - 1 / 10) * ((162 * x) / 49 + 18 / 49)) / 4\n        (exp(-(9 * x - 4)^2 - (9 * y - 7)^2) * (162 * y - 126)) / 5 - (3 * exp(-(9 * x - 2)^2 / 4 - (9 * y - 2)^2 / 4) * ((81 * y) / 2 - 9)) / 4 - (exp(-(9 * x - 7)^2 / 4 - (9 * y - 3)^2 / 4) * ((81 * y) / 2 - 27 / 2)) / 2 - (27 * exp(-(9 * y) / 10 - (9 * x + 1)^2 / 49 - 1 / 10)) / 40]\n    (x, y) -> @SVector[tanh(9 * x - 9 * y)^2 - 1\n        1 - tanh(9 * x - 9 * y)^2]\n    (x, y) -> @SVector[-((108 * x - 36) * (cos((27 * y) / 5) + 5 / 4)) / (6 * (3 * x - 1)^2 + 6)^2\n        -(27 * sin((27 * y) / 5)) / (5 * (6 * (3 * x - 1)^2 + 6))]\n    (x, y) -> @SVector[-(exp(-(81 * (x - 1 / 2)^2) / 16 - (81 * (y - 1 / 2)^2) / 16) * ((81 * x) / 8 - 81 / 16)) / 3\n        -(exp(-(81 * (x - 1 / 2)^2) / 16 - (81 * (y - 1 / 2)^2) / 16) * ((81 * y) / 8 - 81 / 16)) / 3]\n    (x, y) -> @SVector[-(exp(-(81 * (x - 1 / 2)^2) / 4 - (81 * (y - 1 / 2)^2) / 4) * ((81 * x) / 2 - 81 / 4)) / 3\n        -(exp(-(81 * (x - 1 / 2)^2) / 4 - (81 * (y - 1 / 2)^2) / 4) * ((81 * y) / 2 - 81 / 4)) / 3]\n    (x, y) -> @SVector[-(162 * x - 81) / (18 * (64 - 81 * (y - 1 / 2)^2 - 81 * (x - 1 / 2)^2)^(1 / 2))\n        -(162 * y - 81) / (18 * (64 - 81 * (y - 1 / 2)^2 - 81 * (x - 1 / 2)^2)^(1 / 2))]\n    (x, y) -> @SVector[27 * y * cos(27 * x * y) + 13 * exp(-(x - y)^2 / 4) * sin(13 * x - 13 * y) + exp(-(x - y)^2 / 4) * cos(13 * x - 13 * y) * (x / 2 - y / 2)\n        27 * x * cos(27 * x * y) - 13 * exp(-(x - y)^2 / 4) * sin(13 * x - 13 * y) - exp(-(x - y)^2 / 4) * cos(13 * x - 13 * y) * (x / 2 - y / 2)]\n]\nconst Hf = [\n    (x, y) -> @SMatrix[(162*exp(-(9 * x - 4)^2 - (9 * y - 7)^2))/5-(243*exp(-(9 * y) / 10 - (9 * x + 1)^2 / 49 - 1 / 10))/98-(243*exp(-(9 * x - 2)^2 / 4 - (9 * y - 2)^2 / 4))/8-(81*exp(-(9 * x - 7)^2 / 4 - (9 * y - 3)^2 / 4))/4+(3*exp(-(9 * y) / 10 - (9 * x + 1)^2 / 49 - 1 / 10)*((162*x)/49+18/49)^2)/4+(3*exp(-(9 * x - 2)^2 / 4 - (9 * y - 2)^2 / 4)*((81*x)/2-9)^2)/4+(exp(-(9 * x - 7)^2 / 4 - (9 * y - 3)^2 / 4)*((81*x)/2-63/2)^2)/2-(exp(-(9 * x - 4)^2 - (9 * y - 7)^2)*(162*x-72)^2)/5 (27*exp(-(9 * y) / 10 - (9 * x + 1)^2 / 49 - 1 / 10)*((162*x)/49+18/49))/40+(3*exp(-(9 * x - 2)^2 / 4 - (9 * y - 2)^2 / 4)*((81*x)/2-9)*((81*y)/2-9))/4+(exp(-(9 * x - 7)^2 / 4 - (9 * y - 3)^2 / 4)*((81*x)/2-63/2)*((81*y)/2-27/2))/2-(exp(-(9 * x - 4)^2 - (9 * y - 7)^2)*(162*x-72)*(162*y-126))/5\n        (27*exp(-(9 * y) / 10 - (9 * x + 1)^2 / 49 - 1 / 10)*((162*x)/49+18/49))/40+(3*exp(-(9 * x - 2)^2 / 4 - (9 * y - 2)^2 / 4)*((81*x)/2-9)*((81*y)/2-9))/4+(exp(-(9 * x - 7)^2 / 4 - (9 * y - 3)^2 / 4)*((81*x)/2-63/2)*((81*y)/2-27/2))/2-(exp(-(9 * x - 4)^2 - (9 * y - 7)^2)*(162*x-72)*(162*y-126))/5 (243*exp(-(9 * y) / 10 - (9 * x + 1)^2 / 49 - 1 / 10))/400+(162*exp(-(9 * x - 4)^2 - (9 * y - 7)^2))/5-(243*exp(-(9 * x - 2)^2 / 4 - (9 * y - 2)^2 / 4))/8-(81*exp(-(9 * x - 7)^2 / 4 - (9 * y - 3)^2 / 4))/4+(3*exp(-(9 * x - 2)^2 / 4 - (9 * y - 2)^2 / 4)*((81*y)/2-9)^2)/4+(exp(-(9 * x - 7)^2 / 4 - (9 * y - 3)^2 / 4)*((81*y)/2-27/2)^2)/2-(exp(-(9 * x - 4)^2 - (9 * y - 7)^2)*(162*y-126)^2)/5]\n    (x, y) -> @SMatrix[-2*tanh(9 * x - 9 * y)*(9*tanh(9 * x - 9 * y)^2-9) 2*tanh(9 * x - 9 * y)*(9*tanh(9 * x - 9 * y)^2-9)\n        2*tanh(9 * x - 9 * y)*(9*tanh(9 * x - 9 * y)^2-9) -2*tanh(9 * x - 9 * y)*(9*tanh(9 * x - 9 * y)^2-9)]\n    (x, y) -> @SMatrix[(2*(108*x-36)^2*(cos((27 * y) / 5)+5/4))/(6*(3*x-1)^2+6)^3-(108*(cos((27 * y) / 5)+5/4))/(6*(3*x-1)^2+6)^2 (27*sin((27 * y) / 5)*(108*x-36))/(5*(6*(3*x-1)^2+6)^2)\n        (27*sin((27 * y) / 5)*(108*x-36))/(5*(6*(3*x-1)^2+6)^2) -(729 * cos((27 * y) / 5))/(25*(6*(3*x-1)^2+6))]\n    (x, y) -> @SMatrix[(exp(-(81 * (x - 1 / 2)^2) / 16 - (81 * (y - 1 / 2)^2) / 16)*((81*x)/8-81/16)^2)/3-(27*exp(-(81 * (x - 1 / 2)^2) / 16 - (81 * (y - 1 / 2)^2) / 16))/8 (exp(-(81 * (x - 1 / 2)^2) / 16 - (81 * (y - 1 / 2)^2) / 16)*((81*x)/8-81/16)*((81*y)/8-81/16))/3\n        (exp(-(81 * (x - 1 / 2)^2) / 16 - (81 * (y - 1 / 2)^2) / 16)*((81*x)/8-81/16)*((81*y)/8-81/16))/3 (exp(-(81 * (x - 1 / 2)^2) / 16 - (81 * (y - 1 / 2)^2) / 16)*((81*y)/8-81/16)^2)/3-(27*exp(-(81 * (x - 1 / 2)^2) / 16 - (81 * (y - 1 / 2)^2) / 16))/8]\n    (x, y) -> @SMatrix[(exp(-(81 * (x - 1 / 2)^2) / 4 - (81 * (y - 1 / 2)^2) / 4)*((81*x)/2-81/4)^2)/3-(27*exp(-(81 * (x - 1 / 2)^2) / 4 - (81 * (y - 1 / 2)^2) / 4))/2 (exp(-(81 * (x - 1 / 2)^2) / 4 - (81 * (y - 1 / 2)^2) / 4)*((81*x)/2-81/4)*((81*y)/2-81/4))/3\n        (exp(-(81 * (x - 1 / 2)^2) / 4 - (81 * (y - 1 / 2)^2) / 4)*((81*x)/2-81/4)*((81*y)/2-81/4))/3 (exp(-(81 * (x - 1 / 2)^2) / 4 - (81 * (y - 1 / 2)^2) / 4)*((81*y)/2-81/4)^2)/3-(27*exp(-(81 * (x - 1 / 2)^2) / 4 - (81 * (y - 1 / 2)^2) / 4))/2]\n    (x, y) -> @SMatrix[-(162 * x - 81)^2/(36*(64-81*(y-1/2)^2-81*(x-1/2)^2)^(3/2))-9/(64-81*(y-1/2)^2-81*(x-1/2)^2)^(1/2) -((162 * x - 81) * (162 * y - 81))/(36*(64-81*(y-1/2)^2-81*(x-1/2)^2)^(3/2))\n        -((162 * x - 81) * (162 * y - 81))/(36*(64-81*(y-1/2)^2-81*(x-1/2)^2)^(3/2)) -(162 * y - 81)^2/(36*(64-81*(y-1/2)^2-81*(x-1/2)^2)^(3/2))-9/(64-81*(y-1/2)^2-81*(x-1/2)^2)^(1/2)]\n    (x, y) -> @SMatrix[(339*exp(-(x - y)^2 / 4)*cos(13 * x - 13 * y))/2-729*y^2*sin(27 * x * y)-exp(-(x - y)^2 / 4)*cos(13 * x - 13 * y)*(x/2-y/2)^2-26*exp(-(x - y)^2 / 4)*sin(13 * x - 13 * y)*(x/2-y/2) 27*cos(27 * x * y)-(339*exp(-(x - y)^2 / 4)*cos(13 * x - 13 * y))/2-729*x*y*sin(27 * x * y)+exp(-(x - y)^2 / 4)*cos(13 * x - 13 * y)*(x/2-y/2)^2+26*exp(-(x - y)^2 / 4)*sin(13 * x - 13 * y)*(x/2-y/2)\n        27*cos(27 * x * y)-(339*exp(-(x - y)^2 / 4)*cos(13 * x - 13 * y))/2-729*x*y*sin(27 * x * y)+exp(-(x - y)^2 / 4)*cos(13 * x - 13 * y)*(x/2-y/2)^2+26*exp(-(x - y)^2 / 4)*sin(13 * x - 13 * y)*(x/2-y/2) (339*exp(-(x - y)^2 / 4)*cos(13 * x - 13 * y))/2-729*x^2*sin(27 * x * y)-exp(-(x - y)^2 / 4)*cos(13 * x - 13 * y)*(x/2-y/2)^2-26*exp(-(x - y)^2 / 4)*sin(13 * x - 13 * y)*(x/2-y/2)]\n]","category":"page"},{"location":"compare/#Assessment-Metrics","page":"Comparison of Interpolation Methods","title":"Assessment Metrics","text":"","category":"section"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"We define here the methods we will use for assessing the quality of an interpolant. ","category":"page"},{"location":"compare/#Surface-Smoothness","page":"Comparison of Interpolation Methods","title":"Surface Smoothness","text":"","category":"section"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"There are many ways to measure how rough or how smooth a surface is. I don't consider anything so complicated here, and instead I just compare normal vectors at each point. For a function f, the normal vector at a point (x y f(x y)) is given by (-partial_xf -partial_yf 1)sqrt1 + partial_xf^2 + partial_yf^2. ","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"For the interpolated surface, we cannot rely so readily on the generated gradients for this purpose. We instead triangulate the interpolated surface and then, for each point on the surface, take an angle-weighted average of the normal vectors at each triangle adjoining that point. The functions for computing this average are given below.","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"function normal_to_triangle(p₁, p₂, p₃, z₁, z₂, z₃)\n    x₁, y₁ = getxy(p₁)\n    x₂, y₂ = getxy(p₂)\n    x₃, y₃ = getxy(p₃)\n    Δ = x₁ * y₂ - x₂ * y₁ - x₁ * y₃ + x₃ * y₁ + x₂ * y₃ - x₃ * y₂\n    s₁ = (y₂ - y₃) / Δ\n    s₂ = (y₃ - y₁) / Δ\n    s₃ = (y₁ - y₂) / Δ\n    s₄ = (x₃ - x₂) / Δ\n    s₅ = (x₁ - x₃) / Δ\n    s₆ = (x₂ - x₁) / Δ\n    α = s₁ * z₁ + s₂ * z₂ + s₃ * z₃\n    β = s₄ * z₁ + s₅ * z₂ + s₆ * z₃\n    ∇norm = sqrt(1 + α^2 + β^2)\n    ∇ = @SVector[-α, -β, 1.0]\n    return ∇ / ∇norm\nend\nfunction normal_to_triangle(tri, z, i, j, k)\n    p₁, p₂, p₃ = get_point(tri, i, j, k)\n    z₁, z₂, z₃ = z[i], z[j], z[k]\n    return normal_to_triangle(p₁, p₂, p₃, z₁, z₂, z₃)\nend\n\nfunction ∠(v₁, v₂)\n    # acos is not reliable: https://people.eecs.berkeley.edu/~wkahan/Triangle.pdf, https://scicomp.stackexchange.com/a/27694/42528\n    a = norm(v₁)\n    b = norm(v₂)\n    c = norm(v₁ - v₂)\n    if a < b\n        a, b = b, a\n    end\n    μ = if b ≥ c\n        c - (a - b)\n    else\n        b - (a - c)\n    end\n    num = ((a - b) + c) * μ\n    den = (a + (b + c)) * ((a - c) + b)\n    θ = 2atan(sqrt(num / den))\n    return θ\nend\nfunction ∠(tri, z, i, j, k)\n    # Angle between pᵢpⱼ and pᵢpₖ\n    p₁, p₂, p₃ = get_point(tri, i, j, k)\n    z₁, z₂, z₃ = z[i], z[j], z[k]\n    px, py = getxy(p₁)\n    qx, qy = getxy(p₂)\n    rx, ry = getxy(p₃)\n    v₁ = @SVector[qx - px, qy - py, z₂ - z₁]\n    v₂ = @SVector[rx - px, ry - py, z₃ - z₁]\n    return ∠(v₁, v₂)\nend\n\nfunction average_normal_vector(tri, z, i)\n    # Using the mean-weighted-angle formula: https://doi.org/10.1007/s00371-004-0271-1\n    n = @SVector[0.0, 0.0, 1.0]\n    neighbouring_edges = get_adjacent2vertex(tri, i)\n    for (j, k) in neighbouring_edges\n        if !DelaunayTriangulation.is_ghost_triangle(i, j, k)\n            ψ = ∠(tri, z, i, j, k)\n            n = n + ψ * normal_to_triangle(tri, z, i, j, k)\n        end\n    end\n    return n / norm(n)\nend\n\nfunction compare_normal_vectors(tri, z, i, ∇f::Function)\n    # Maybe this is similar to https://doi.org/10.1007/978-3-319-40548-3_19?\n    # The description is so vague.\n    p = get_point(tri, i)\n    x, y = getxy(p)\n    n̄̂ = average_normal_vector(tri, z, i)\n    nx, ny = ∇f(x, y)\n    n = @SVector[-nx, -ny, 1.0]\n    n̂ = n / norm(n)\n    return rad2deg(∠(n̄̂, n̂))\nend\nfunction compare_normal_vectors(tri, z, ∇f::Function, interior_idx)\n    return [compare_normal_vectors(tri, z, i, ∇f) for i in interior_idx]\nend","category":"page"},{"location":"compare/#Comparing-Raw-Values-Locally","page":"Comparison of Interpolation Methods","title":"Comparing Raw Values Locally","text":"","category":"section"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"To compare raw values, such as heights or Hessians, we use the error definition varepsilon(y yhat) = 2y - yhat  y + yhat:","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"function compare_quantities(ŷ, y, interior_idx)\n    ε = 2norm.(ŷ .- y) ./ norm.(ŷ .+ y)\n    return to_unit(ε[interior_idx])\nend\nfunction to_unit(μ)\n    return max.(μ, sqrt(eps(Float64)))\nend\nto_mat(H) = @SMatrix[H[1] H[3]; H[3] H[2]]","category":"page"},{"location":"compare/#Local-Analysis-Function","page":"Comparison of Interpolation Methods","title":"Local Analysis Function","text":"","category":"section"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"The function we use for our local analysis is defined below.","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"function analysis_function!(df, tri, triq, x, y, xq, yq, fidx, itp_method, diff_method, interior_idx)\n    g = f[fidx]\n    ∇g = ∇f[fidx]\n    Hg = Hf[fidx]\n    z = g.(x, y)\n    itp = interpolate(tri, z; derivatives=true, method=diff_method)\n    ∂ = differentiate(itp, 2)\n\n    ẑ = itp(xq, yq; method=itp_method)\n    ∇̂Ĥ = ∂(xq, yq; method=diff_method, interpolant_method=itp_method)\n    ∇̂ = SVector{2,Float64}.(first.(∇̂Ĥ))\n    Ĥ = to_mat.(last.(∇̂Ĥ))\n\n    z = g.(xq, yq)\n    ∇ = ∇g.(xq, yq)\n    H = Hg.(xq, yq)\n    εz = compare_quantities(ẑ, z, interior_idx)\n    ε∇ = compare_quantities(∇̂, ∇, interior_idx)\n    εH = compare_quantities(Ĥ, H, interior_idx)\n    εn = compare_normal_vectors(triq, ẑ, ∇g, interior_idx)\n\n    _df = DataFrame(\n        :z_exact => z[interior_idx],\n        :z_approx => ẑ[interior_idx],\n        :∇_exact => ∇[interior_idx],\n        :∇_approx => ∇̂[interior_idx],\n        :H_exact => H[interior_idx],\n        :H_approx => Ĥ[interior_idx],\n        :z_error => εz,\n        :∇_error => ε∇,\n        :H_error => εH,\n        :n_error => εn,\n        :itp_method => itp_alias_map[itp_method],\n        :diff_method => diff_alias_map[diff_method],\n        :f_idx => fidx\n    )\n    append!(df, _df)\n    return df\nend\nfunction analysis_function(tri, triq, x, y, xq, yq, interior_idx)\n    df = DataFrame(\n        z_exact=Float64[],\n        z_approx=Float64[],\n        ∇_exact=SVector{2,Float64}[],\n        ∇_approx=SVector{2,Float64}[],\n        H_exact=SMatrix{2, 2, Float64}[],\n        H_approx=SMatrix{2, 2, Float64}[],\n        z_error=Float64[],\n        ∇_error=Float64[],\n        H_error=Float64[],\n        n_error=Float64[],\n        itp_method=Symbol[],\n        diff_method=Symbol[],\n        f_idx=Int[]\n    )\n    for fidx in eachindex(f, ∇f, Hf)\n        for itp_method in itp_methods\n            for diff_method in diff_methods\n                analysis_function!(df, tri, triq, x, y, xq, yq, fidx, itp_method, diff_method, interior_idx)\n            end\n        end\n    end\n    return df\nend","category":"page"},{"location":"compare/#Quantitative-Local-Analysis","page":"Comparison of Interpolation Methods","title":"Quantitative Local Analysis","text":"","category":"section"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"Let's now give the results for our quantitative local analysis. We use our analysis_function as:","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"df = analysis_function(tri, triq, x, y, xq, yq, interior_idx)\ngdf = groupby(df, [:f_idx, :itp_method, :diff_method])","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"We plot these results as follows.","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"const alph = join('a':'z')\nfig = Figure(fontsize=64)\nz_ax = [Axis(fig[i, 1], xlabel=L\"\\varepsilon\", ylabel=L\"F(\\varepsilon)\",\n    title=L\"(%$(alph[i])1): $z$ $\\varepsilon$ for $f_{%$i}\", titlealign=:left,\n    width=600, height=400, xscale=log10) for i in eachindex(f, ∇f, Hf)]\n∇_ax = [Axis(fig[i, 2], xlabel=L\"\\varepsilon\", ylabel=L\"F(\\varepsilon)\",\n    title=L\"(%$(alph[i])2): $\\nabla$ $\\varepsilon$ for $f_{%$i}\", titlealign=:left,\n    width=600, height=400, xscale=log10) for i in eachindex(f, ∇f, Hf)]\nH_ax = [Axis(fig[i, 3], xlabel=L\"\\varepsilon\", ylabel=L\"F(\\varepsilon)\",\n    title=L\"(%$(alph[i])3): $H$ $\\varepsilon$ for $f_{%$i}\", titlealign=:left,\n    width=600, height=400, xscale=log10) for i in eachindex(f, ∇f, Hf)]\nn_ax = [Axis(fig[i, 4], xlabel=L\"\\varepsilon\", ylabel=L\"F(\\varepsilon)\",\n    title=L\"(%$(alph[i])4): $n$ $\\varepsilon$ for $f_{%$i}\", titlealign=:left,\n    width=600, height=400) for i in eachindex(f, ∇f, Hf)]\nf_ax = [Axis3(fig[i, 5], xlabel=L\"x\", ylabel=L\"y\", zlabel=L\"f_{%$i}(x, y)\",\n    title=L\"(%$(alph[i])5): $f_{%$i}$'s surface\", titlealign=:left,\n    width=600, height=400, azimuth=azimuths[i]) for i in eachindex(f, ∇f, Hf)]\nxℓ = [\n    (1e-5, 1.0) (1e-3, 1.0) (1e-2, 1.0) (0.0, 5.0)\n    (1e-5, 1.0) (1e-2, 1.0) (1e-1, 1.0) (0.0, 5.0)\n    (1e-6, 1e-1) (1e-5, 1.0) (1e-2, 1.0) (0.0, 2.0)\n    (1e-6, 1e-1) (1e-4, 1e-1) (1e-2, 1.0) (0.0, 1.0)\n    (1e-5, 1e-1) (1e-3, 1.0) (1e-2, 1.0) (0.0, 2.0)\n    (1e-8, 1e-1) (1e-5, 1e-1) (1e-2, 1e-1) (0.0, 0.5)\n    (1e-2, 1.0) (1e-2, 1.0) (1e-1, 1.0) (0.0, 15.0)\n]\nfor i in eachindex(f)\n    xlims!(z_ax[i], xℓ[i, 1]...)\n    xlims!(∇_ax[i], xℓ[i, 2]...)\n    xlims!(H_ax[i], xℓ[i, 3]...)\n    xlims!(n_ax[i], xℓ[i, 4]...)\nend\nfor (f_idx, itp_alias, diff_alias) in keys(gdf)\n    _df = gdf[(f_idx, itp_alias, diff_alias)]\n    clr = colors[itp_alias]\n    ls = linestyles[diff_alias]\n    _z_ax = z_ax[f_idx]\n    _∇_ax = ∇_ax[f_idx]\n    _H_ax = H_ax[f_idx]\n    _n_ax = n_ax[f_idx]\n    z_error = _df.z_error\n    ∇_error = _df.∇_error\n    H_error = _df.H_error\n    n_error = _df.n_error\n    ecdfplot!(_z_ax, z_error, color=clr, linestyle=ls, linewidth=7)\n    ecdfplot!(_∇_ax, ∇_error, color=clr, linestyle=ls, linewidth=7)\n    ecdfplot!(_H_ax, H_error, color=clr, linestyle=ls, linewidth=7)\n    if itp_alias ≠ :Nearest\n        ecdfplot!(_n_ax, n_error, color=clr, linestyle=ls, linewidth=7)\n    end\nend\nfor f_idx in eachindex(f)\n    g = f[f_idx]\n    fz = [g(x, y) for x in xg2, y in yg2]\n    _f_ax = f_ax[f_idx]\n    surface!(_f_ax, xg2, yg2, fz)\nend\n[Legend(\n    fig[i:(i+1), 6],\n    [line_elements, style_elements],\n    [string.(keys(colors)), string.(keys(linestyles))],\n    [\"Interpolant\", \"Differentiator\"],\n    titlesize=78,\n    labelsize=78,\n    patchsize=(100, 30)\n) for i in (1, 3, 5)]\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"<figure>\n    <img src='../figures/interpolant_comparison.png', alt'Comparing interpolants'><br>\n</figure>","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"For these plots:","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"The first column shows the errors for the height values.\nThe second column shows the errors in the gradients.\nThe third column shows the errors in the Hessians.\nThe fourth column shows the errors in the normal vectors. The nearest neighbour interpolant is not shown for this column since it is (unsurprisingly) consistently the worst method.\nThe fifth column shows the exact surface.","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"Note that we use the empirical cumulative distribution function, and the function F(varepsilon) in the y-axis could also be interpreted as the ``fraction of data''. For example, the plot in (f3) shows the curve for the Hiyoshi interpolant being much further to the left than the other curves, implying that Hiyoshi has by far outperformed the others.","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"Let us discuss what we see from each column.","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"The smooth interpolants (Sibson(1), Farin(1), and Hiyoshi(2)) seem to have the best performance here, with derivative information generated with the direct method, appear to perform the best when measuring differences in heights, with the nearest neighbour interpolant having the worst performance. The Laplace(), Triangle(), and Sibson(0) interpolants seem to have similar performance, although the Triangle() interpolant probably wouldn't have as high a performance if we had e.g. randomly spaced data (analysed later).\nThe gradient estimates seem to depend only on the smoothness of the interpolant rather than the interpolant itself, and the Direct() method seems to outperform the Iterative() method for generating derivatives. In particular, for generating gradients, the Hiyoshi(2), Sibson(1), or Farin(1) interpolants perform equally as well, provided the Direct() method is used.\nThe results for the Hessians are similar to the gradient results.\nFor the smoothness of the interpolated surfaces, the Hiyoshi(2) and Farin(1) results are consistently the best, with Sibson(1) a close competitor. The Triangle() interpolant leads to the least smooth surface of those considered. Similarly to the gradient and Hessians results, the Direct() approach leads to the best results compared to Iterative().","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"Overall, the smooth interpolants lead to the best results, and of the non-smooth interpolants (Sibson(0), Laplace(), Triangle(), Nearest()), Sibson(0) seems to have the best results. For derivative generation, Direct() seems to give the best results.","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"Note that the analysis here does not consider whether using cubic terms in Direct() methods makes a difference, or whether varying alpha for the Iterative() approach makes a difference.","category":"page"},{"location":"compare/#Qualitative-Local-Analysis","page":"Comparison of Interpolation Methods","title":"Qualitative Local Analysis","text":"","category":"section"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"Now we will visualise the surfaces produced by the interpolants. Based on the above results, we will only consider Direct() for derivative generation. Let us first look at the surfaces themselves.","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"considered_itp = eachindex(itp_methods)\nconsidered_fidx = eachindex(f)\nfig = Figure(fontsize=72, resolution = (4800, 4900))\nax = [\n    Axis3(fig[i, j],\n        xlabel=L\"x\",\n        ylabel=L\"y\",\n        zlabel=L\"f(x, y)\",\n        title=L\"(%$(alph[i])%$(j)): ($f_{%$i}$, %$(itp_aliases[j]))\",\n        titlealign=:left,\n        width=600,\n        height=600,\n        azimuth=azimuths[i]\n    )\n    for i in considered_fidx, j in considered_itp\n]\nfor (j, i) in enumerate(considered_fidx)\n    for (ℓ, k) in enumerate(considered_itp)\n        _gdf = gdf[(i, itp_aliases[k], diff_aliases[1])]\n        _ax = ax[j, ℓ]\n        _z = _gdf.z_approx\n        surface!(_ax, xq[interior_idx], yq[interior_idx], _z)\n        xlims!(_ax, 0, 1)\n        ylims!(_ax, 0, 1)\n        hidedecorations!(_ax)\n    end\nend\nfig","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"<figure>\n    <img src='../figures/3d_visual_interpolant_comparison.png', alt'Comparing interpolant surfaces'><br>\n</figure>","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"We can clearly see some of the roughness produced by the non-smooth interpolants. Hiyoshi(2) seems to have the best visual quality.","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"To assess these results further, we can look at the errors. The function we use for this is:","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"function plot_errors(considered_fidx, considered_itp, gdf, interior_idx, error_type, colorranges)\n    fig = Figure(fontsize=72)\n    ax = [\n        Axis(fig[i, j],\n            xlabel=L\"x\",\n            ylabel=L\"y\",\n            title=L\"(%$(alph[i])%$(j)): ($f_{%$i}$, %$(itp_aliases[j]))\",\n            titlealign=:left,\n            width=600,\n            height=600,\n        )\n        for i in considered_fidx, j in considered_itp\n    ]\n    for (j, i) in enumerate(considered_fidx)\n        for (ℓ, k) in enumerate(considered_itp)\n            _gdf = gdf[(i, itp_aliases[k], diff_aliases[1])]\n            _ax = ax[j, ℓ]\n            ε = _gdf[!, error_type]\n            heatmap!(_ax, xq[interior_idx], yq[interior_idx], ε, colorrange=colorranges[j])\n            xlims!(_ax, 0, 1)\n            ylims!(_ax, 0, 1)\n            hidedecorations!(_ax)\n        end\n    end\n    resize_to_layout!(fig)\n    fig\nend","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"For the height errors:","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"z_colorranges = [(1e-4, 0.01), (1e-5, 0.1), (1e-3, 0.05), (1e-4, 0.01), (1e-3, 0.1), (1e-4, 0.01), (1e-2, 0.5)]\nfig = plot_errors(considered_fidx, considered_itp, gdf, interior_idx, :z_error, z_colorranges)","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"<figure>\n    <img src='../figures/2d_visual_interpolant_comparison_z_error.png', alt'Heatmap of 2D height errors'><br>\n</figure>","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"To compare the gradients, we use:","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"∇_colorranges = [(1e-2, 0.2), (1e-2, 1.0), (1e-2, 0.01), (1e-3, 0.01), (1e-2, 0.05), (1e-3, 0.01), (1e-2, 0.25)]\nfig = plot_errors(considered_fidx, considered_itp, gdf, interior_idx, :∇_error, ∇_colorranges)","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"<figure>\n    <img src='../figures/2d_visual_interpolant_comparison_grad_error.png', alt'Heatmap of 2D gradient errors'><br>\n</figure>","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"Next, the Hessians are compared:","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"H_colorranges = [(1e-1, 0.5), (0.2, 0.8), (1e-1, 0.2), (1e-2, 0.2), (1e-1, 0.25), (1e-2, 0.1), (1e-1, 0.8)]\nfig = plot_errors(considered_fidx, considered_itp, gdf, interior_idx, :H_error, H_colorranges)","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"<figure>\n    <img src='../figures/2d_visual_interpolant_comparison_hess_error.png', alt'Heatmap of 2D Hessian errors'><br>\n</figure>","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"Finally, we compare the normal vector fields:","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"n_colorranges = [(0, 5), (0, 5), (0, 2), (0, 1), (0, 2), (0, 2.5), (0, 15)]\nfig = plot_errors(considered_fidx, considered_itp, gdf, interior_idx, :n_error, n_colorranges)","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"<figure>\n    <img src='../figures/2d_visual_interpolant_comparison_normal_error.png', alt'Heatmap of 2D normal errors'><br>\n</figure>","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"Judging from these results, again the Hiyoshi(2) and Farin(1) methods have the best performance across all metrics.","category":"page"},{"location":"compare/#Quantiative-Global-Analysis","page":"Comparison of Interpolation Methods","title":"Quantiative Global Analysis","text":"","category":"section"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"Now we will use global metrics to assess the interpolation quality. A limitation of the above discussion is that we are considering a fixed data set. Here, we instead consider random data sets (with the same test functions) and weighted averages of the local errors. We will measure the errors as a function of the median edge length of the data set's underlying triangulation. Note that, in these random data sets, we will not maintain a convex hull of 0 1^2. Lastly, we will use a stricter tolerance on whether to classify a point as being inside of the convex hull in this case, now using a tol = 0.1 rather than tol = 0.01. The global metric we use is 100sqrtfracsum_i y_i - hat y_i^2sum_j hat y_i^2:","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"function rrmse(y, ŷ) # interior_indices already applied\n    num = 0.0\n    den = 0.0\n    for (yᵢ, ŷᵢ) in zip(y, ŷ)\n        if all(isfinite, (yᵢ..., ŷᵢ...))\n            num += norm(yᵢ .- ŷᵢ)^2\n            den += norm(ŷᵢ)^2\n        end\n    end\n    return 100sqrt(num / den)\nend","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"For comparing the normal vector errors, we will just use the median. To compute the median edge length of a triangulation, we use:","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"function median_edge_length(tri)\n    lengths = zeros(DelaunayTriangulation.num_solid_edges(tri))\n    for (k, (i, j)) in (enumerate ∘ each_solid_edge)(tri)\n        p, q = get_point(tri, i, j)\n        px, py = getxy(p)\n        qx, qy = getxy(q)\n        ℓ = sqrt((qx - px)^2 + (qy - py)^2)\n        lengths[k] = ℓ\n    end\n    return median(lengths)\nend","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"The function we use for performing our random analysis is:","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"function random_analysis_function(nsamples, triq, xq, yq, tol, rng)\n    npoints = rand(rng, 50:2500)\n    xs = [rand(rng, 50) for _ in 1:nsamples]\n    ys = [rand(rng, 50) for _ in 1:nsamples]\n    tris = [triangulate(tuple.(x, y); rng) for (x, y) in zip(xs, ys)]\n    [refine!(tri; max_points=npoints) for tri in tris]\n    xs = [first.(get_points(tri)) for tri in tris]\n    ys = [last.(get_points(tri)) for tri in tris]\n    exterior_idxs = [identify_exterior_points(xq, yq, get_points(tri), get_convex_hull_indices(tri); tol=tol) for tri in tris]\n    interior_idxs = [filter(∉(exterior_idx), eachindex(xq, yq)) for exterior_idx in exterior_idxs]\n    median_lengths = [median_edge_length(tri) for tri in tris]\n    sortidx = sortperm(median_lengths)\n    [permute!(obj, sortidx) for obj in (xs, ys, tris, exterior_idxs, interior_idxs, median_lengths)]\n    dfs = Channel{DataFrame}(nsamples)\n    Base.Threads.@threads for i in 1:nsamples\n        tri = tris[i]\n        x = xs[i]\n        y = ys[i]\n        interior_idx = interior_idxs[i]\n        put!(dfs, analysis_function(tri, triq, x, y, xq, yq, interior_idx))\n        println(\"Processed simulation $i.\")\n    end\n    close(dfs)\n    dfs = collect(dfs)\n    df = DataFrame(\n        f_idx=Int64[],\n        itp_method=Symbol[],\n        diff_method=Symbol[],\n        z_rrmse=Float64[],\n        ∇_rrmse=Float64[],\n        H_rrmse=Float64[],\n        n_error_median=Float64[],\n        median_edge_length=Float64[]\n    )\n    for (i, _df) in enumerate(dfs)\n        _gdf = groupby(_df, [:f_idx, :itp_method, :diff_method])\n        _cgdf = combine(_gdf,\n            [:z_exact, :z_approx] => ((z_exact, z_approx) -> rrmse(z_exact, z_approx)) => :z_rrmse,\n            [:∇_exact, :∇_approx] => ((∇_exact, ∇_approx) -> rrmse(∇_exact, ∇_approx)) => :∇_rrmse,\n            [:H_exact, :H_approx] => ((H_exact, H_approx) -> rrmse(H_exact, H_approx)) => :H_rrmse,\n            :n_error => median => :n_error_median)\n        _cgdf[!, :median_edge_length] .= median_lengths[i]\n        append!(df, _cgdf)\n    end\n    _gdf = groupby(df, [:f_idx, :itp_method, :diff_method])\n    return _gdf\nend","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"Now let's do the actual analysis.","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"nsamples = 50\nrng = StableRNG(998881)\ntol = 1e-1\nrandom_results = random_analysis_function(nsamples, triq, xq, yq, tol, rng)","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"With these results, we can plot the errors for each method.","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"fig = Figure(fontsize=64)\nz_ax = [Axis(fig[i, 1], xlabel=L\"$ $Median edge length\", ylabel=L\"$z$ error\",\n    title=L\"(%$(alph[i])1): $f_{%$i}\", titlealign=:left,\n    width=600, height=400, yscale=log10) for i in eachindex(f, ∇f, Hf)]\n∇_ax = [Axis(fig[i, 2], xlabel=L\"$ $Median edge length\", ylabel=L\"$\\nabla$ error\",\n    title=L\"(%$(alph[i])2): $f_{%$i}\", titlealign=:left,\n    width=600, height=400, yscale=log10) for i in eachindex(f, ∇f, Hf)]\nH_ax = [Axis(fig[i, 3], xlabel=L\"$ $Median edge length\", ylabel=L\"$H$ error\",\n    title=L\"(%$(alph[i])3): $f_{%$i}\", titlealign=:left,\n    width=600, height=400, yscale=log10) for i in eachindex(f, ∇f, Hf)]\nn_ax = [Axis(fig[i, 4], xlabel=L\"$ $Median edge length\", ylabel=L\"$n$ error\",\n    title=L\"(%$(alph[i])4): $f_{%$i}\", titlealign=:left,\n    width=600, height=400, yscale=log10) for i in eachindex(f, ∇f, Hf)]\nfor (f_idx, itp_alias, diff_alias) in keys(random_results)\n    _df = random_results[(f_idx, itp_alias, diff_alias)]\n    _df = filter(:itp_method => !=(:Nearest), _df)\n    clr = colors[itp_alias]\n    ls = linestyles[diff_alias]\n    _z_ax = z_ax[f_idx]\n    _∇_ax = ∇_ax[f_idx]\n    _H_ax = H_ax[f_idx]\n    _n_ax = n_ax[f_idx]\n    x = _df.median_edge_length\n    z_error = _df.z_rrmse\n    ∇_error = _df.∇_rrmse\n    H_error = _df.H_rrmse\n    n_error = _df.n_error_median\n    lines!(_z_ax, x, z_error, color=clr, linestyle=ls, linewidth=7)\n    lines!(_∇_ax, x, ∇_error, color=clr, linestyle=ls, linewidth=7)\n    lines!(_H_ax, x, H_error, color=clr, linestyle=ls, linewidth=7)\n    lines!(_n_ax, x, n_error, color=clr, linestyle=ls, linewidth=7)\nend\n[Legend(\n    fig[i:(i+1), 6],\n    [line_elements, style_elements],\n    [string.(keys(colors)), string.(keys(linestyles))],\n    [\"Interpolant\", \"Differentiator\"],\n    titlesize=78,\n    labelsize=78,\n    patchsize=(100, 30)\n) for i in (1, 3, 5)]\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"<figure>\n    <img src='../figures/median_edge_length_comparisons.png', alt'Median edge length comparisons'><br>\n</figure>","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"Once again, the Hiyoshi(2) and Farin(1) methods seem preferable, and Direct() seems to have greater results over Iterative().","category":"page"},{"location":"compare/#Computation-Times","page":"Comparison of Interpolation Methods","title":"Computation Times","text":"","category":"section"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"It is important to note that using the smooth interpolants comes at a cost of greater running time. If n is the number of natural neighbours around a point boldsymbol x_0, then computing f^textHIY(boldsymbol x_0) is about mathcal O(n^5), and f^textFAR(boldsymbol x_0) is mathcal O(n^3). Derivative generation also has this complexity when using these interpolants (since it involves solving a least squares problem). Of course, this complexity doesn't typically matter so much since (1) many points are being evaluated at using multithreading and (2) points have, on average, six natural neighbours only in most triangulations.","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"Let us explore here how long it takes to compute the interpolant as a function of the number of natural neighbours. There are many ways to measure this properly, e.g. collecting large samples of computation times from random data sets, but here we take a simple approach where we contruct a triangulation with a point boldsymbol x_1 = boldsymbol 0 surrounded by m points on a circle. This point boldsymbol x_1 will have approximately m natural neighbours. (Note that we do not care about the number of data points in the dataset since these interpolants are local.) The function we use for this is:","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"function circular_example(m) # extra points are added outside of the circular barrier for derivative generation\n    pts = [(cos(θ) + 1e-6randn(), sin(θ) + 1e-6randn()) for θ = LinRange(0, 2π, (m + 1))][1:end-1] # avoid cocircular points\n    extra_pts = NTuple{2, Float64}[]\n    while length(extra_pts) < 50\n        p = (5randn(), 5randn())\n        if norm(p) > 1.01\n            push!(extra_pts, p)\n        end\n    end\n    append!(pts, extra_pts)\n    tri = triangulate(pts)\n    return tri\nend","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"To perform the benchmarks, we use:","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"function running_time_analysis(itp_method, m_range, g)\n    running_times = zeros(length(m_range))\n    for (i, m) in enumerate(m_range)\n        tri = circular_example(m)\n        z = [g(x, y) for (x, y) in each_point(tri)]\n        itp = interpolate(tri, z; derivatives=true)\n        b = @benchmark $itp($0.0, $0.0; method=$itp_method)\n        running_times[i] = minimum(b.times) / 1e6 # ms\n    end\n    return DataFrame(\n        running_times = running_times, \n        method = itp_alias_map[itp_method],\n        m = m_range\n    )\nend\nfunction running_time_analysis(m_range, g)\n    df = DataFrame(\n        running_times = Float64[],\n        method = Symbol[],\n        m = Int[]\n    )\n    for itp_method in itp_methods\n        _running_times = running_time_analysis(itp_method, m_range, g)\n        append!(df, _running_times)\n    end\n    return df\nend","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"Now let us benchmark and plot the results.","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"m_range = 3:20\ng = f[end]\nrunning_times = running_time_analysis(m_range, g)\n\nfig = data(running_times) *\n      mapping(:m, :running_times) *\n      mapping(color=:method) *\n      visual(Scatter, markersize=14) |> plt ->\n    draw(plt; axis=(width=600, height=400, yscale=log10, xlabel=L\"$ $Number of natural neighbours\", ylabel=L\"$t$ (ms)\"))\nvlines!(fig.figure[1, 1], [6], linewidth=3, linestyle=:dash, color=:black)","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"<figure>\n    <img src='../figures/method_benchmarks.png', alt'Performance of interpolants as a function of the number of natural neighbours'><br>\n</figure>","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"The benchmarks are shown above, with a vertical black line at m = 6 (the expected number of neighbours in a triangulation). We see that the Triangle() and Nearest() methods are the fastest, as we'd expect, and are of course independent of m. The other methods which are C^0 at the data sites, Sibson(0) and Laplace(), are fast and have about the same runtime (both of them essentially perform the same number of operations). When considering smooth interpolants, Sibson(1) is about the same as Sibson(0). The remaining two methods, Farin(1) and Hiyoshi(2), are the slowest as we expect. Hiyoshi(2) can even take more than 10 seconds with 20 natural neighbours (which is not typical, but could happen on real datasets).","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"Overall, while Hiyoshi(2) seems to be the best interpolant, Farin(1) could probably serve as a better default if you are concerned about runtime and don't need second derivative information.","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"To give another benchmark, here are some benchmarks where we take a structured triangulation and evaluate the interpolants at 10000000 query points.","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"x = LinRange(0, 1, 25)\ny = LinRange(0, 1, 25)\npts = vec([(x, y) for x in x, y in y])\ntri = triangulate(pts)\nz = [g(x, y) for (x, y) in each_point(tri)]\nitp = interpolate(tri, z; derivatives = true)\nn = 10_000_000\nxq = rand(n)\nyq = rand(n)","category":"page"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"julia> @time itp(xq, yq; method = Sibson(0));\n  1.418889 seconds (8.42 k allocations: 76.902 MiB, 0.49% compilation time)\n\njulia> @time itp(xq, yq; method = Triangle());\n  0.552120 seconds (8.27 k allocations: 76.854 MiB, 1.38% compilation time)\n\njulia> @time itp(xq, yq; method = Nearest());\n  0.592610 seconds (8.27 k allocations: 76.854 MiB, 1.25% compilation time)\n\njulia> @time itp(xq, yq; method = Laplace());\n  1.142635 seconds (8.27 k allocations: 76.854 MiB, 0.64% compilation time)\n\njulia> @time itp(xq, yq; method = Sibson(1));\n  1.498346 seconds (8.27 k allocations: 76.854 MiB, 0.47% compilation time)\n\njulia> @time itp(xq, yq; method = Farin(1));\n  2.187066 seconds (8.27 k allocations: 76.855 MiB, 0.36% compilation time)\n\njulia> @time itp(xq, yq; method = Hiyoshi(2));\n 13.762652 seconds (9.26 k allocations: 76.920 MiB, 0.06% compilation time)","category":"page"},{"location":"compare/#Conclusion","page":"Comparison of Interpolation Methods","title":"Conclusion","text":"","category":"section"},{"location":"compare/","page":"Comparison of Interpolation Methods","title":"Comparison of Interpolation Methods","text":"Overall, the smooth interpolants have the best performance, with Farin(1) and Hiyoshi(2) typically beating most interpolants. Hiyoshi(2) is much slower than the other interpolants, though, and Farin(1) may be a preferable interpolant if C^1 continuity at the data sites is sufficient. For generating derivatives, the Direct() seems to beat the results with the Iterative() method in most situations.","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"CurrentModule = NaturalNeighbours","category":"page"},{"location":"differentiation_math/#Differentiation","page":"Differentiation Details","title":"Differentiation","text":"","category":"section"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"In this section, we give some of the mathematical detail used for implementing derivative generation, following this thesis. The discussion that follows is primarily sourced from Chapter 6 of the linked thesis. While it is possible to generate derivatives of arbitary order, our discussion here in this section will be limited to gradient and Hessian generation.  These ideas are implemented by the generate_gradients and generate_derivatives functions, which you should use via the differentiate function.","category":"page"},{"location":"differentiation_math/#Generation-at-Data-Sites","page":"Differentiation Details","title":"Generation at Data Sites","text":"","category":"section"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"Let us first consider generating derivatives at the data points used to define the interpolant, (boldsymbol x_1 z_1) ldots (boldsymbol x_n z_n). We consider generating the derivatives at a data site boldsymbol x_0, where boldsymbol x_0 is some point in (boldsymbol x_1ldotsboldsymbol x_n) so that we also know z_0.","category":"page"},{"location":"differentiation_math/#Direct-Generation","page":"Differentiation Details","title":"Direct Generation","text":"","category":"section"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"Let us consider a direct approach first. In this approach, we generate gradients and Hessians jointly. We approximate the underlying function f by a Taylor series expansion,","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"tilde f(boldsymbol x) = z_0 + tilde f_1(boldsymbol x) + tilde f_2(boldsymbol x) + tilde f_3(boldsymbol x)","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"where ","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"beginalign*\ntilde f_1(boldsymbol x) = fracpartial f(boldsymbol x_0)partial x(x-x_0) + fracpartial f(boldsymbol x_0)partial y(y - y_0) \ntilde f_2(boldsymbol x) = frac12fracpartial^2 f(boldsymbol x_0)partial x^2(x - x_0)^2 + frac12partial^2 f(boldsymbol x_0)partial y^2(y - y_0)^2 + fracpartial^2 f(boldsymbol x_0)partial xpartial y(x-x_0)(y-y_0) \ntilde f_3(boldsymbol x) = frac16fracpartial^3 f(boldsymbol x_0)partial x^3(x-x_0)^3 + frac16fracpartial^3 f(boldsymbol x_0)partial y^3(y-y_0)^3 + frac12fracpartial^3 f(boldsymbol x_0)partial x^2partial y(x-x_0)^2(y-y_0) + frac12fracpartial^3 f(boldsymbol x_0)partial xpartial y^2(x-x_0)(y-y_0)^2\nendalign*","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"For gradient generation only, we need only take up to tilde f_1, but for Hessian generation we could include up to tilde f_2 or up to tilde f_3. Whatever option we choose, the neighbourhood that we use for approximating the derivatives needs to be chosen to match the order of the approximation.","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"To choose the neighbourhood, define the d-times iterated neighbourhood of boldsymbol x_0 by ","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"N_0^d = bigcup_i in N_0^d-1 N_i setminus 0 quad N_0^1 = N_0","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"Here, the neighbourhoods are the Delaunay neighbourhoods, not the natural neighbours – for points boldsymbol x_0 that are not one of the existing data sites, natural neighbours are used instead. An example of N_0^1 and N_0^2 both at a data site and away from a data site is shown below, where boldsymbol x_0 is shown in magenta, N_0^1 in blue, and N_0^2 in red (and also includes the blue points).","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"<figure>\n    <img src='../figures/taylor_neighbourhood.png', alt'Iterated neighbourhood examples'><br>\n</figure>","category":"page"},{"location":"differentiation_math/#Gradients","page":"Differentiation Details","title":"Gradients","text":"","category":"section"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"Let's now use the notation defined above to define how gradients are generated in generate_derivatives, without having to estimate Hessians at the same time. The neighbourhood we use is N_0^1, and we take tilde f = z_0 + tilde f_1. We define the following weighted least squares problem for the estimates beta_x, beta_y of partial f(boldsymbol x_0)partial x and partial f(boldsymbol x_0)partial y, respectively:","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"(beta_x beta_y) = textargmin_(beta_x beta_y) sum_i in mathcal N_0^1 W_i left(tilde z_i - beta_1tilde x_i - beta_2tilde y_iright)^2","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"where W_i = 1boldsymbol x_i - boldsymbol x_i^2, tilde z_i = z_i-z_0, tilde x_i=x_i-x_0, and tilde y_i = y_i-y_0. This weighted least squares problem is solved by solving the associated linear system tildeboldsymbol Xboldsymbolbeta = tildeboldsymbol z, where tildeboldsymbol X in mathbb R^m times 2 is defined by (tildeboldsymbol X)_i1 = sqrtW_i(x_i - x_0) and (tildeboldsymbol X)_i2 = sqrtW_i(y_i - y_0), boldsymbolbeta = (beta_1beta_2)^T, and tildeboldsymbol z = (tilde z_1ldotstilde z_m)^T.","category":"page"},{"location":"differentiation_math/#Joint-Gradients-and-Hessians","page":"Differentiation Details","title":"Joint Gradients and Hessians","text":"","category":"section"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"Hessians can similarly be estimated, although currently they must be estimated jointly with gradients. We take tilde f = z_0 + tilde f_1 + tilde f_2 in the following discussion, although taking up to tilde f_3 has an obvious extension. (The reason to also allow for estimating up to the cubic terms is because sometimes it provides better estimates for the Hessians than only going up to the quadratic terms – see the examples in Chapter 6 here.) ","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"Defining beta_1 = partial f(boldsymbol x_0)partial x, beta_2 = partial f(boldsymbol x_0)partial y, beta_3 = partial^2 f(boldsymbol x_0)partial x^2, beta_4 = partial^2 f(boldsymbol x_0)partial y^2, and beta_5 = partial^2 f(boldsymbol x_0)partial xpartial y, we have the following weighted least squares problem with boldsymbolbeta=(beta_1beta_2beta_3beta_4beta_5)^T:","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"boldsymbolbeta = textargmin_boldsymbolbeta sum_i in N_0^2 W_ileft(tilde z_i - beta_1tilde x_i - beta_2tilde y_i - frac12beta_3tilde x_i^2 - frac12beta_4tilde y_i^2 - beta_5tilde x_itilde y_iright)^2","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"using similar notation as in the gradient case. (In the cubic case, use N_0^3 and go up to beta_9, discarding beta_6ldotsbeta_9 at the end.) The associated linear system in this case has matrix tildeboldsymbol X in mathbb R^m times 2 (m = N_0^2) defined by (tildeboldsymbol X)_i1 = sqrtW_itilde x_i, (tildeboldsymbol X)_i2 = sqrtW_itilde y_i, (tildeboldsymbol X)_i3 = sqrtW_itilde x_i^2, (tildeboldsymbol X)_i4 = sqrtW_itilde y_i^2, and (tildeboldsymbol X)_i5 = sqrtW_itilde x_itilde y_i.","category":"page"},{"location":"differentiation_math/#Iterative-Generation","page":"Differentiation Details","title":"Iterative Generation","text":"","category":"section"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"Now we discuss iterative generation. Here, we suppose that we have already estimated gradients at all of the data sites boldsymbol x_i neighbouring boldsymbol x_0 using the direct approach. To help with the notation, we will let boldsymbol g_i^1 denote our initial estimate of the gradient at a point boldsymbol x_i, and the gradient and Hessian that we are now estimating at boldsymbol x_0 are given by boldsymbol g_0^2 and boldsymbol H_0^2, respectively.","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"We define the following loss function, where beta_i = 1boldsymbol x_i-boldsymbol x_0 and alpha in (0 1):","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"beginalign*\nmathcal L(boldsymbol g_0^2 boldsymbol H_0^2) = sum_i in mathcal N_0 W_ileftalpha mathcal L_1^i(boldsymbol g_0^2 boldsymbol H_0^2)^2 + (1-alpha)L_2^i(boldsymbol g_0^2 boldsymbol H_0^2)^2right \nmathcal L_1^i(boldsymbol g_0^2 boldsymbol H_0^2)^2 = leftfrac12(boldsymbol x_i-boldsymbol x_0)^Tboldsymbol H_0^2(boldsymbol x_i - boldsymbol x_0) + (boldsymbol x_i-boldsymbol x_0)^Tboldsymbol g_0^2 + z_0-z_iright^2 \nmathcal L_2^i(boldsymbol g_0^2 boldsymbol H_0^2) = leftboldsymbol H_0^2 boldsymbol x_i + boldsymbol g_0^2 - boldsymbol g_i^1right^2\nendalign*","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"This objective function combines the losses between tilde f(boldsymbol x_i) and z_i, and between boldsymbol nabla tilde f(boldsymbol x_i) and boldsymbol g_i^1, weighting them by some parameter alpha in (0 1) (typically alpha approx 01 is a reasonable default). After some basic algebra and calculus,  it is possible to show that minimising mathcal L is the same as solving ","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"overlineboldsymbol A^Toverlineboldsymbol w + overlineboldsymbol B^Toverlineboldsymbol g_1 + overlineboldsymbol C^Toverlineboldsymbol g_2 = left(overlineboldsymbol A^Toverlineboldsymbol A + overlineboldsymbol B^Toverlineboldsymbol B + overlineboldsymbol C^Toverlineboldsymbol Cright)boldsymbol theta","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"where we define:","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"beginalign*\ntilde z_i = z_i - z_0 \nW_i = frac1boldsymbol x_i-boldsymbol x_0^2\ngamma_i = sqrtfracalphaW_i \ngamma_i^prime = sqrtfrac1-alphaW_i\noverlineboldsymbol A_i = gamma_i beginbmatrix x_i-x_0  y_i-y_0  frac12(x_i-x_0)^2  frac12(y_i-y_0)^2  (x_i-x_0)(y_i-y_0) endbmatrix \noverlineboldsymbol B_i  = gamma_i^prime beginbmatrix 1  0  x_i - x_0  0  y_i - y_0 endbmatrix \noverlineboldsymbol C_i  = gamma_i^prime beginbmatrix 0  1  0  y_i-y_0  x_i-x_0 endbmatrix \noverlineboldsymbol w = gamma_i tilde z_i \noverlineboldsymbol g_1 = gamma_i^prime g_i1 \noverlineboldsymbol g_2 = gamma_i^prime g_i2 \nboldsymbolbmtheta = beginbmatrix fracpartial f(boldsymbol x_0)partial x  fracpartial f(boldsymbol x_0)partial y  fracpartial^2 f(boldsymbol x_0)partial x^2  fracpartial f(boldsymbol x_0)partial y^2  fracpartial f(boldsymbol x_0)partial xpartial y endbmatrix^T\nendalign*","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"To solve this linear system, let","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"boldsymbol D = beginbmatrix overlineboldsymbol A  overlineboldsymbol B  overlineboldsymbol C endbmatrix quad boldsymbol c = beginbmatrix overlineboldsymbol w  overlineboldsymbol g_1  overlineboldsymbol g_2 endbmatrix","category":"page"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"so that boldsymbol D^Tboldsymbol Dboldsymboltheta = boldsymbol D^Tboldsymbol c. These are just the normal equations for boldsymbol Dboldsymbol theta = boldsymbol c, thus we can estimate the gradients and Hessians by simply solving boldsymbol Dboldsymbol theta = boldsymbol c.","category":"page"},{"location":"differentiation_math/#Generation-Away-from-the-Data-Sites","page":"Differentiation Details","title":"Generation Away from the Data Sites","text":"","category":"section"},{"location":"differentiation_math/","page":"Differentiation Details","title":"Differentiation Details","text":"It is possible to extend these ideas so that we can approximate the derivative at any point boldsymbol x_0 in mathcal C(boldsymbol X). Using the associated interpolant, simply approximate z_0 with the value of the interpolant at boldsymbol x_0, and then replace W_i by lambda_iboldsymbol x_i-boldsymbol x_0, where lambda_i is the Sibson coordinate at boldsymbol x_i relative to boldsymbol x_0. If using a direct approach to approximate gradients and Hessians, Sibson coordinates cannot be used (because you can't extend the weights out to N_0^2) and so W_i remains as is in that case. Note that the N_0 neighbourhoods are now the sets of natural neighbours.","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"CurrentModule = NaturalNeighbours","category":"page"},{"location":"differentiation/#Differentiation-Example","page":"Differentiaton","title":"Differentiation Example","text":"","category":"section"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"The purpose of this example is to explore derivative generation. For this, it is important to note that we are thinking of generating derivatives rather than estimating them: Following Alfeld (1989), derivative generation only seeks to find derivatives that best fit our assumptions of the data, i.e. that give a most satisfactory interpolant, rather than trying to find exact derivative values. The complete quote for this by Alfeld (1989) is below:","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"It seems inevitable that in order to obtain an interpolant that is both local and smooth one has to supply derivative data. Typically, such data are not part of the interpolation problem and have to be made up from existing func tional data. This process is usually referred as derivative estimation, but this is probably a misnomer. The objective is not to estimate existing but unknown values of derivatives. Instead, it is to generate values that will yield a satisfactory interpolant. Even if an underlying primitive function did exist it might be preferable to use derivative values that differ from the exact ones. (For example, a maximum error might be decreased by using the \"wrong\" derivative values.) Therefore, I prefer the term derivative generation rather than derivative estimation.","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"For the purpose of this exploration, we use Franke's test function. This function, introduced by Franke and Nielson (1980), is given by ","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"beginalign*\nf(x y) = frac34expleft-frac(9x-2)^2 + (9y-2)^24right + frac34expleft-frac(9x+1)^249 - frac9y+110right \n+ frac12expleft-frac(9x-7)^2 + (9y-3)^24right - frac15expleft-(9x-4)^2 - (9y-7)^2right\nendalign*","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"This function, and its derivatives, are defined below.","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"f = (x, y) -> 0.75 * exp(-((9 * x - 2)^2 + (9 * y - 2)^2) / 4) + 0.75 * exp(-(9 * x + 1)^2 / 49 - (9 * y + 1) / 10) + 0.5 * exp(-((9 * x - 7)^2 + (9 * y - 3)^2) / 4) - 0.2 * exp(-(9 * x - 4)^2 - (9 * y - 7)^2)\nf′ = (x, y) -> [(exp(-(9 * x - 4)^2 - (9 * y - 7)^2) * (162 * x - 72)) / 5 - (3 * exp(-(9 * x - 2)^2 / 4 - (9 * y - 2)^2 / 4) * ((81 * x) / 2 - 9)) / 4 - (exp(-(9 * x - 7)^2 / 4 - (9 * y - 3)^2 / 4) * ((81 * x) / 2 - 63 / 2)) / 2 - (3 * exp(-(9 * y) / 10 - (9 * x + 1)^2 / 49 - 1 / 10) * ((162 * x) / 49 + 18 / 49)) / 4\n    (exp(-(9 * x - 4)^2 - (9 * y - 7)^2) * (162 * y - 126)) / 5 - (3 * exp(-(9 * x - 2)^2 / 4 - (9 * y - 2)^2 / 4) * ((81 * y) / 2 - 9)) / 4 - (exp(-(9 * x - 7)^2 / 4 - (9 * y - 3)^2 / 4) * ((81 * y) / 2 - 27 / 2)) / 2 - (27 * exp(-(9 * y) / 10 - (9 * x + 1)^2 / 49 - 1 / 10)) / 40]\nf′′ = (x, y) -> [(162*exp(-(9 * x - 4)^2 - (9 * y - 7)^2))/5-(243*exp(-(9 * y) / 10 - (9 * x + 1)^2 / 49 - 1 / 10))/98-(243*exp(-(9 * x - 2)^2 / 4 - (9 * y - 2)^2 / 4))/8-(81*exp(-(9 * x - 7)^2 / 4 - (9 * y - 3)^2 / 4))/4+(3*exp(-(9 * y) / 10 - (9 * x + 1)^2 / 49 - 1 / 10)*((162*x)/49+18/49)^2)/4+(3*exp(-(9 * x - 2)^2 / 4 - (9 * y - 2)^2 / 4)*((81*x)/2-9)^2)/4+(exp(-(9 * x - 7)^2 / 4 - (9 * y - 3)^2 / 4)*((81*x)/2-63/2)^2)/2-(exp(-(9 * x - 4)^2 - (9 * y - 7)^2)*(162*x-72)^2)/5 (27*exp(-(9 * y) / 10 - (9 * x + 1)^2 / 49 - 1 / 10)*((162*x)/49+18/49))/40+(3*exp(-(9 * x - 2)^2 / 4 - (9 * y - 2)^2 / 4)*((81*x)/2-9)*((81*y)/2-9))/4+(exp(-(9 * x - 7)^2 / 4 - (9 * y - 3)^2 / 4)*((81*x)/2-63/2)*((81*y)/2-27/2))/2-(exp(-(9 * x - 4)^2 - (9 * y - 7)^2)*(162*x-72)*(162*y-126))/5\n    (27*exp(-(9 * y) / 10 - (9 * x + 1)^2 / 49 - 1 / 10)*((162*x)/49+18/49))/40+(3*exp(-(9 * x - 2)^2 / 4 - (9 * y - 2)^2 / 4)*((81*x)/2-9)*((81*y)/2-9))/4+(exp(-(9 * x - 7)^2 / 4 - (9 * y - 3)^2 / 4)*((81*x)/2-63/2)*((81*y)/2-27/2))/2-(exp(-(9 * x - 4)^2 - (9 * y - 7)^2)*(162*x-72)*(162*y-126))/5 (243*exp(-(9 * y) / 10 - (9 * x + 1)^2 / 49 - 1 / 10))/400+(162*exp(-(9 * x - 4)^2 - (9 * y - 7)^2))/5-(243*exp(-(9 * x - 2)^2 / 4 - (9 * y - 2)^2 / 4))/8-(81*exp(-(9 * x - 7)^2 / 4 - (9 * y - 3)^2 / 4))/4+(3*exp(-(9 * x - 2)^2 / 4 - (9 * y - 2)^2 / 4)*((81*y)/2-9)^2)/4+(exp(-(9 * x - 7)^2 / 4 - (9 * y - 3)^2 / 4)*((81*y)/2-27/2)^2)/2-(exp(-(9 * x - 4)^2 - (9 * y - 7)^2)*(162*y-126)^2)/5]","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"Here is the surface of f along with its derivatives.","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"using CairoMakie\nfunction plot_f(fig, x, y, vals, title, i, show_3d=true, zlabel=\"z\")\n    ax = Axis(fig[1, i], xlabel=\"x\", ylabel=\"y\", width=600, height=600, title=title, titlealign=:left)\n    c = contourf!(ax, x, y, vals, color=vals, colormap=:viridis,  extendhigh=:auto)\n    if show_3d\n        ax = Axis3(fig[2, i], xlabel=\"x\", ylabel=\"y\", zlabel=zlabel, width=600, height=600, title=\" \", titlealign=:left, azimuth=0.49)\n        surface!(ax, x, y, vals, color=vals, colormap=:viridis)\n    end\n    return c\nend\n\nx = LinRange(0, 1, 100)\ny = LinRange(0, 1, 100)\nz = [f(x, y) for x in x, y in y]\n∇ = [f′(x, y) for x in x, y in y]\n∇₁ = first.(∇)\n∇₂ = last.(∇)\nH = [f′′(x, y) for x in x, y in y]\nH₁₁ = getindex.(H, 1)\nH₁₂ = getindex.(H, 2)\nH₂₂ = getindex.(H, 4)\n\nfig = Figure(fontsize = 36)\nplot_f(fig, x, y, z, \"(a): f\", 1, true, \"z\")\nplot_f(fig, x, y, ∇₁, \"(b): ∂f/∂x\", 2, true, \"∂f/∂x\")\nplot_f(fig, x, y, ∇₂, \"(c): ∂f/∂y\", 3, true,  \"∂f/∂y\")\nplot_f(fig, x, y, H₁₁, \"(d): ∂²f/∂x²\", 4, true, \"∂²f/∂x²\")\nplot_f(fig, x, y, H₂₂, \"(f): ∂²f/∂y²\", 5, true, \"∂²f/∂y²\")\nplot_f(fig, x, y, H₁₂, \"(e): ∂²f/∂x∂y\", 6, true,  \"∂²f/∂x∂y\")\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"<figure>\n    <img src='../figures/differentiation_exact_surfaces.png', alt'Plots of the interpolants'><br>\n</figure>","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"For our analysis, we use the following data set:","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"using StableRNGs \nusing DelaunayTriangulation \nusing CairoMakie\nrng = StableRNG(9199)\nx = rand(rng, 500)\ny = rand(rng, 500)\nz = f.(x, y)\ntri = triangulate([x'; y'])\nvorn = voronoi(tri)\n\nfig = Figure(fontsize=36, resolution=(1800, 600))\nax = Axis(fig[1, 1], xlabel=\"x\", ylabel=\"y\", width=600, height=600, title=\"(a): Data and triangulation\", titlealign=:left)\nscatter!(ax, x, y, color=:black, markersize=9)\ntriplot!(ax, tri, color=:black, linewidth=2, show_convex_hull=false)\nvoronoiplot!(ax, vorn, strokecolor=:blue)\nxlims!(ax, 0, 1)\nylims!(ax, 0, 1)\n\nax = Axis3(fig[1, 2], xlabel=\"x\", ylabel=\"y\", zlabel=\"z\", width=600, height=600, azimuth=0.25, title=\"(b): Function values\", titlealign=:left)\ntriangles = [T[j] for T in each_solid_triangle(tri), j in 1:3]\nsurface!(ax, x, y, z)\nscatter!(ax, x, y, z, color=:black, markersize=9)\n\ncolgap!(fig.layout, 1, 75)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"<figure>\n    <img src='../figures/example_data.png', alt'Plots of the data'><br>\n</figure>","category":"page"},{"location":"differentiation/#Generation-at-the-Data-Sites","page":"Differentiaton","title":"Generation at the Data Sites","text":"","category":"section"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"To start with the example, we consider generating the dervatives at the data sites.","category":"page"},{"location":"differentiation/#Gradients","page":"Differentiaton","title":"Gradients","text":"","category":"section"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"Let us first estimate some gradients using the direct method.","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"using NaturalNeighbours\nusing DelaunayTriangulation \nusing CairoMakie \nusing LinearAlgebra\n\nfunction plot_f2(fig, x, y, vals, title, i, tri, levels, show_3d=true, zlabel=\"z\")\n    triangles = [T[j] for T in each_solid_triangle(tri), j in 1:3]\n    ax = Axis(fig[1, i], xlabel=\"x\", ylabel=\"y\", width=600, height=600, title=title, titlealign=:left)\n    c = tricontourf!(ax, x, y, vals, color=vals, triangulation=triangles', colormap=:viridis, extendhigh=:auto, levels=levels)\n    if show_3d\n        ax = Axis3(fig[2, i], xlabel=\"x\", ylabel=\"y\", zlabel=zlabel, width=600, height=600, title=\" \", titlealign=:left, azimuth=0.49)\n        mesh!(ax, hcat(x, y, vals), triangles, color=vals, colormap=:viridis, colorrange=extrema(levels))\n    end\n    return c\nend\nfunction plot_gradients(∇g, tri, f′, x, y)\n    ∇g1 = first.(∇g)\n    ∇g2 = last.(∇g)\n    fig = Figure(fontsize=36, resolution=(2400, 600))\n    plot_f2(fig, x, y, ∇g1, \"(a): ∂f̂/∂x\", 1, tri, -3.5:0.5:3.0, true, \"∂f̂/∂x\")\n    plot_f2(fig, x, y, ∇g2, \"(b): ∂f̂/∂y\", 3, tri, -3.5:0.5:3.0, true, \"∂f̂/∂y\")\n    plot_f2(fig, x, y, getindex.(f′.(x, y), 1), \"(c): ∂f/∂x\", 2, tri, -3.5:0.5:3.0, true, \"∂f/∂x\")\n    plot_f2(fig, x, y, getindex.(f′.(x, y), 2), \"(d): ∂f/∂y\", 4, tri, -3.5:0.5:3.0, true, \"∂f/∂y\")\n    plot_f2(fig, x, y, norm.(collect.(∇g) .- f′.(x, y)), \"(e): Gradient error\", 5, tri, 0:0.1:0.5, true, \"|∇ε|\")\n    resize_to_layout!(fig)\n    ε = 100sqrt(sum((norm.(collect.(∇g) .- f′.(x, y))) .^ 2) / sum(norm.(∇g) .^ 2))\n    return fig, ε\nend\n\npoints = [x'; y']\nz = f.(x, y)\ntri = triangulate(points)\n∇g = generate_gradients(tri, z)\nfig, ε = plot_gradients(∇g, tri, f′, x, y)","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"julia> ε\n10.251180094083372","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"<figure>\n    <img src='../figures/gradient_data.png', alt'Gradients'><br>\n</figure>","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"A 10% error is not terrible, and the derivatives we obtain are reasonable.","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"Let's also look at the results when we jointly estimate the gradients and Hessians (this is the default option).","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"∇gr, _ = generate_derivatives(tri, z; method=Direct())\nfig, ε = plot_gradients(∇gr, tri, f′, x, y)","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"julia> ε\n7.717791597731752","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"<figure>\n    <img src='../figures/joint_gradient_data.png', alt'Joint Gradients'><br>\n</figure>","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"The figures are smoother, and the error has now decreased to 7.7% – an improvement. We could also try and see what happens if we use the Iterative() approach, using the first gradients we got as the initial gradients, or we could see what happens with use_cubic_terms=false for the Direct() method, but we won't show that here.","category":"page"},{"location":"differentiation/#Hessians","page":"Differentiaton","title":"Hessians","text":"","category":"section"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"Let's now look at estimating Hessians. We first consider the direct approach, including cubic terms.","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"to_mat(H::NTuple{3,Float64}) = [H[1] H[3]; H[3] H[2]]\nfunction plot_hessians(H, tri, f′′, x, y)\n    H₁₁ = getindex.(H, 1)\n    H₁₂ = getindex.(H, 3)\n    H₂₂ = getindex.(H, 2)\n\n    fig = Figure(fontsize=36, resolution=(2400, 600))\n    plot_f2(fig, x, y, H₁₁, \"(a): ∂²f̂/∂x²\", 1, tri, -35:5:30, true, \"∂²f̂/∂x²\")\n    plot_f2(fig, x, y, H₂₂, \"(c): ∂²f̂/∂y²\", 3, tri, -35:5:30, true, \"∂²f̂/∂y²\")\n    plot_f2(fig, x, y, H₁₂, \"(e): ∂²f̂/∂x∂y\", 5, tri, -35:5:30, true, \"∂²f̂/∂x∂y\")\n    plot_f2(fig, x, y, getindex.(f′′.(x, y), 1), \"(b): ∂²f/∂x²\", 2, tri, -35:5:30, true, \"∂²f/∂x²\")\n    plot_f2(fig, x, y, getindex.(f′′.(x, y), 4), \"(d): ∂²f/∂y²\", 4, tri, -35:5:30, true, \"∂²f/∂y²\")\n    plot_f2(fig, x, y, getindex.(f′′.(x, y), 2), \"(f): ∂²f/∂x∂y\", 6, tri, -35:5:30, true, \"∂²f/∂x∂y\")\n    resize_to_layout!(fig)\n    ε = 100sqrt(sum((norm.(to_mat.(H) .- f′′.(x, y))) .^ 2) / sum(norm.(to_mat.(H)) .^ 2))\n    return fig, ε\nend\n_, Hg = generate_derivatives(tri, z)\nfig, ε = plot_hessians(Hg, tri, f′′, x, y)","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"julia> ε\n42.085578794275605","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"<figure>\n    <img src='../figures/hessian_data.png', alt'Cubic Hessians'><br>\n</figure>","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"The error is certainly quite large, but remember that we are doing derivative generation here rather than estimation. Judging from the figures themselves, the derivatives we have obtained are actually pretty good. ","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"Let's now see what happens if we only go up to quadratic terms.","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"_, Hg = generate_derivatives(tri, z, use_cubic_terms=false)\nfig, ε = plot_hessians(Hg, tri, f′′, x, y)","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"julia> ε\n35.20873081559232","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"<figure>\n    <img src='../figures/hessian_data_no_cubic.png', alt'Quadratic Hessians'><br>\n</figure>","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"The error has actually decreased, and the figures do indeed look better. So, in this case, including cubic terms does not improve the results significantly (sometimes it does).","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"What if we used the iterative approach? ","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"_, Hg = generate_derivatives(tri, z, method=Iterative()) # the gradients will be generated first automatically\nfig, ε = plot_hessians(Hg, tri, f′′, x, y)","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"julia> ε\n39.58481626576425","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"<figure>\n    <img src='../figures/hessian_data_iterative.png', alt'Iterative Hessians'><br>\n</figure>","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"The results are slightly worse, and varying alpha doesn't seem to do much.","category":"page"},{"location":"differentiation/#Generation-Away-from-the-Data-Sites","page":"Differentiaton","title":"Generation Away from the Data Sites","text":"","category":"section"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"Now let's consider derivative generation away from the data sites. The function differentiate is used for this. We first construct our interpolant, ensuring we set derivatives=true so that we get the gradients at the data sites first, and then we differentiate.","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"itp = interpolate(tri, z; derivatives=true, method = Direct(), use_cubic_terms=false)\n∂ = differentiate(itp, 1)","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"The second argument specifies the order of the resulting derivatives. Since we specify order 1, we will get gradients (partial_xfpartial_yf).","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"Let's now define the grid for differentiating.","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"xg = LinRange(0, 1, 500)\nyg = LinRange(0, 1, 500)\n_x = vec([x for x in xg, _ in yg])\n_y = vec([y for _ in xg, y in yg])","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"We can now evaluate ∂. To approximate the function values at each point, we will use the Sibson(1) method, since this will incorporate the gradient information. I would really like to eventually get Hiyoshi's C^2 interpolant, as discussed in Section 3.2.7.3 here, as this will also give us C^2 continuity at the derivative sites and thus give smoother surfaces (noting some complexity issues discussed in Section 6.5 of the linked thesis), but I've just not found the time to comprehend how to best implement it yet / digest the spline notation (see issue #1 if you are interested on contributing to this). Note also that, just as with the interpolation methods, it is best to give vectors to ∂. Lastly, since we are evaluating away from the data sites, remember that the Sibson coordinates are now incorporated into the weights of the associated weighted least squares problem (that you could disable if you for some reason wanted to with use_sibson_weight=false).","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"∇g = ∂(_x, _y; interpolant_method = Sibson(1))","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"Let's now plot our gradients. Note that there are some Inf values in the computed gradients, and these correspond to points evaluated outside of the convex hull of our data sites.","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"function rrmserr(z, ẑ)\n    num = 0.0\n    den = 0.0\n    for (zᵢ, ẑᵢ) in zip(z, ẑ)\n        if all(isfinite, (zᵢ..., ẑᵢ...))\n            num += norm(zᵢ .- ẑᵢ)^2\n            den += norm(ẑᵢ)^2\n        end\n    end\n    # num /= length(ẑ)\n    return 100sqrt(num / den)\nend\nfunction plot_f2(fig, x, y, vals, title, i, levels, show_3d=true, zlabel=\"z\")\n    ax = Axis(fig[1, i], xlabel=\"x\", ylabel=\"y\", width=600, height=600, title=title, titlealign=:left)\n    c = contourf!(ax, x, y, vals, color=vals, colormap=:viridis, extendhigh=:auto, levels=levels)\n    if show_3d\n        ax = Axis3(fig[2, i], xlabel=\"x\", ylabel=\"y\", zlabel=zlabel, width=600, height=600, title=\" \", titlealign=:left, azimuth=0.49)\n        surface!(ax, x, y, vals, color=vals, colormap=:viridis, colorrange=extrema(levels))\n    end\n    return c\nend\nfunction plot_gradients(∇g, f′, xg, yg)\n    ∇g = reshape(∇g, (length(xg), length(yg)))\n    ∇g1 = first.(∇g)\n    ∇g2 = last.(∇g)\n    ∇f = [f′(x, y) for x in xg, y in yg]\n    fig = Figure(fontsize=36, resolution=(2400, 600))\n    plot_f2(fig, xg, yg, ∇g1, \"(a): ∂f̂/∂x\", 1, -3.5:0.5:3.0, true, \"∂f̂/∂x\")\n    plot_f2(fig, xg, yg, ∇g2, \"(b): ∂f̂/∂y\", 3, -3.5:0.5:3.0, true, \"∂f̂/∂y\")\n    plot_f2(fig, xg, yg, first.(∇f), \"(c): ∂f/∂x\", 2, -3.5:0.5:3.0, true, \"∂f/∂x\")\n    plot_f2(fig, xg, yg, last.(∇f), \"(d): ∂f/∂y\", 4, -3.5:0.5:3.0, true, \"∂f/∂y\")\n    plot_f2(fig, xg, yg, norm.(collect.(∇g) .- ∇f), \"(e): Gradient error\", 5, 0:0.1:0.5, true, \"|∇ε|\")\n    resize_to_layout!(fig)\n    ε = rrmserr(∇f, collect.(∇g))\n    return fig, ε\nend\nfig, ε = plot_gradients(∇g, f′, xg, yg)","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"julia> ε\n13.185747607565729","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"<figure>\n    <img src='../figures/gradient_surface.png', alt'Evaluated Gradient'><br>\n</figure>","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"There are of course some strange artifacts near the convex hull, but the results are not terrible. Let's see what happens to the error if we instead use the other interpolant methods.","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"other_methods = [Sibson(), Laplace(), Nearest(), Triangle()]\n∇gs = [∂(_x, _y; interpolant_method=method) for method in other_methods]\n∇f = [f′(x, y) for x in xg, y in yg]\nεs = [rrmserr(∇f, collect.(∇g)) for ∇g in ∇gs]","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"julia> hcat(other_methods, εs)\n4×2 Matrix{Any}:\n Sibson{0}()    28.6753\n Laplace{0}()   25.499\n Nearest{0}()   69.5744\n Triangle{0}()  27.7737","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"Of course, the other methods are much worse.","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"Now let's go up to second order.","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"function plot_hessians(H, f′′, xg, yg)\n    H = reshape(H, (length(xg), length(yg)))\n    H₁₁ = getindex.(H, 1)\n    H₁₂ = getindex.(H, 3)\n    H₂₂ = getindex.(H, 2)\n    Hf = [f′′(x, y) for x in xg, y in yg]\n    fig = Figure(fontsize=36, resolution=(2400, 600))\n    plot_f2(fig, xg, yg, H₁₁, \"(a): ∂²f̂/∂x²\", 1, -35:5:30, true, \"∂²f̂/∂x²\")\n    plot_f2(fig, xg, yg, H₂₂, \"(c): ∂²f̂/∂y²\", 3, -35:5:30, true, \"∂²f̂/∂y²\")\n    plot_f2(fig, xg, yg, H₁₂, \"(e): ∂²f̂/∂x∂y\", 5, -35:5:30, true, \"∂²f̂/∂x∂y\")\n    plot_f2(fig, xg, yg, getindex.(Hf, 1), \"(b): ∂²f/∂x²\", 2, -35:5:30, true, \"∂²f/∂x²\")\n    plot_f2(fig, xg, yg, getindex.(Hf, 4), \"(d): ∂²f/∂y²\", 4, -35:5:30, true, \"∂²f/∂y²\")\n    plot_f2(fig, xg, yg, getindex.(Hf, 2), \"(f): ∂²f/∂x∂y\", 6, -35:5:30, true, \"∂²f/∂x∂y\")\n    resize_to_layout!(fig)\n    ε = rrmserr(Hf, to_mat.(H))\n    return fig, ε\nend\n∂ = differentiate(itp, 2)\n∇Hg = ∂(_x, _y; interpolant_method=Sibson(1), method = Iterative())\n∇g = first.(∇Hg)\nHg = last.(∇Hg)\nzlims!(figH.content[4], -25, 25)\nfig∇, ε∇ = plot_gradients(∇g, f′, xg, yg)\nfigH, εH = plot_hessians(Hg, f′′, xg, yg)","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"julia> ε∇\n19.07546882353911\n\njulia> εH\n51.1267212244942","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"<figure>\n    <img src='../figures/gradient_surface_2.png', alt'Evaluated Gradient'><br>\n</figure>","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"<figure>\n    <img src='../figures/hessian_surface.png', alt'Evaluated Hessian'><br>\n</figure>","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"The gradients actually look better here, despite the greater error, especially around the convex hull. The Hessians are a bit problematic around the convex hull especially, but we are really asking a lot of the interpolant to get Hessians unfortunately. ","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"Let's see if the direct approach can give us any improvements (the default is Iterative() since we have derivative information in the interpolant).","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"∇Hg = ∂(_x, _y; interpolant_method=Sibson(1), method=Direct())\n∇g = first.(∇Hg)\nHg = last.(∇Hg)\nfig∇, ε∇ = plot_gradients(∇g, f′, xg, yg)\nfigH, εH = plot_hessians(Hg, f′′, xg, yg)\nzlims!(figH.content[4], -25, 25)","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"julia> ε∇\n9.853286514069882\n\njulia> εH\n46.7610990050276","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"<figure>\n    <img src='../figures/gradient_surface_2_direct.png', alt'Evaluated Gradient'><br>\n</figure>","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"<figure>\n    <img src='../figures/hessian_surface_direct.png', alt'Evaluated Hessian'><br>\n</figure>","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"Indeed, both the gradients and the Hessians appear to have improved, with some difficulties at the convex hull. Perhaps a better way to measure the error is to only include points that are away fro the convex hull. The following function can do this for us:","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"function rrmserr(z, ẑ, tri, x, y)\n    num = 0.0\n    den = 0.0 \n    points = get_point(tri)\n    ch = get_convex_hull_indices(tri)\n    for (zᵢ, ẑᵢ, xᵢ, yᵢ) in zip(z, ẑ, x, y)\n        q = (xᵢ, yᵢ)\n        δ = DelaunayTriangulation.distance_to_polygon(q, points, ch)\n        if δ > 1e-4 && all(isfinite, (zᵢ..., ẑᵢ...))\n            num += norm(zᵢ .- ẑᵢ)^2\n            den += norm(ẑᵢ)^2\n        end\n    end\n    # num /= length(ẑ)\n    return 100sqrt(num / den)\nend","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"If we instead use this metric, then:","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"julia> ε∇_nohull = rrmserr(f′.(_x, _y), ∇g, ∂, _x, _y)\n7.479964687679311\n\njulia> εH_nohull = rrmserr(f′′.(_x, _y), to_mat.(Hg), ∂, _x, _y)\n38.884740966379056","category":"page"},{"location":"differentiation/","page":"Differentiaton","title":"Differentiaton","text":"The errors are smaller, though not by much.","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"CurrentModule = NaturalNeighbours","category":"page"},{"location":"interpolation_math/#Interpolation","page":"Interpolation Details","title":"Interpolation","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"In this section, we give some of the mathematical background behind natural neighbour interpolation, and other interpolation methods provided from this package. The discussion here will be limited, but you can see this thesis or this Wikipedia article for more information. The discussion that follows is primarily sourced from the linked thesis. These ideas are implemented by the interpolate function.","category":"page"},{"location":"interpolation_math/#Voronoi-Tessellation","page":"Interpolation Details","title":"Voronoi Tessellation","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"We need to first define the Voronoi tessellation. We consider some set of points boldsymbol X = boldsymbol x_1 ldots boldsymbol x_m subseteq mathbb R^2. The Voronoi tessellation of boldsymbol X, denoted mathcal V(boldsymbol X), is a set of convex polygons V_boldsymbol x_1 ldots V_boldsymbol x_m, also called tiles, such that ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"beginequation*\nV_boldsymbol x_i = boldsymbol x in mathbb R^2  boldsymbol x - boldsymbol x_i leq boldsymbol x - boldsymbol x_j boldsymbol x_j in boldsymbol X\nendequation*","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"In particular, any point in V_boldsymbol x_i is closer to boldsymbol x_i than it is to any other point in boldsymbol X. We will also denote V_boldsymbol x_i by V_i. DelaunayTriangulation.jl is used to build mathcal V(boldsymbol X). An example of a Voronoi tessellation is shown below.","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"<figure>\n    <img src='../figures/example_tessellation.png', alt='Voronoi Tessellation'><br>\n</figure>","category":"page"},{"location":"interpolation_math/#Natural-Neighbours","page":"Interpolation Details","title":"Natural Neighbours","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"See that the tiles of the tessellation in the figure above intersect along a line, called the Voronoi facet, that we denote by mathcal F_ij = mathcal V_i cap mathcal V_j. Whenever mathcal F_ij neq emptyset, we say that boldsymbol x_i and boldsymbol x_j are natural neighbours in boldsymbol X. We denote the set of natural neighbours to a point boldsymbol x in boldsymbol X by N(boldsymbol x) subseteq boldsymbol X, and we denote the corresponding indices by N_i = j  boldsymbol x_j in N(boldsymbol x_j).","category":"page"},{"location":"interpolation_math/#Natural-Neighbour-Coordinates","page":"Interpolation Details","title":"Natural Neighbour Coordinates","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"We represent points locally using what are known as natural neighbour coordinates, which are based on the nearby Voronoi tiles. In particular, we make the following definition: Any set of convex coordinates boldsymbol lambda (convex means that lambda_i geq 0 for each i) of boldsymbol x with respect to the natural neighbours N(boldsymbol x) of boldsymbol x that satisfies: ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"lambda_i  0 iff boldsymbol x_i in N(boldsymbol x),\nboldsymbol lambda is continuous with respect to boldsymbol x, ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"is called a set of natural neighbour coordinates of boldsymbol x in boldsymbol X, or just the natural neighbour coordinates of boldsymbol x, or the local coordinates of boldsymbol x.","category":"page"},{"location":"interpolation_math/#Natural-Neighbour-Interpolation","page":"Interpolation Details","title":"Natural Neighbour Interpolation","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Now that we have some definitions, we can actually define the steps involved in natural neighbour interpolation. We are supposing that we have some data (boldsymbol x_i z_i) for i=1ldotsm, and we want to interpolate this data at some point boldsymbol x_0 in mathcal C(boldsymbol X), where boldsymbol X is the point set (boldsymbol x_1ldotsboldsymbol x_m) and mathcal C(boldsymbol X) is the convex hull of boldsymbol x. We let Z denote the function values (z_1ldotsz_m).","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"The steps are relatively straight forward.","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"First, compute local coordinates boldsymbol lambda(boldsymbol x_0) with respect to the natural neighbours N(boldsymbol x_0).\nCombine the values z_i associated with boldsymbol x_i in N(boldsymbol x) using some blending function varphi(boldsymbol lambda Z).","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"To consider the second step, note that a major motivation for working with local coordinates is the following fact: The coordinates boldsymbol lambda that we compute can be used to represent our point boldsymbol x_0 as boldsymbol x_0 = sum_i in N_0 lambda_i(boldsymbol x_0)boldsymbol x_i, a property known as the local coordinates property (Sibson, 1980), or the natural neighbour coordinates property if boldsymbol lambda is convex (as we assume them to be). ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"In particular, the coordinates boldsymbol lambda determine how much each point boldsymbol x_i in N(boldsymbol x_0) contributes to the representation of our query point boldsymbol x_0, hence the term \"natural\". So, a natural interpolant is to simply take this linear combination and replace boldsymbol x_i by z_i, giving the scattered data interpolant","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"f(boldsymbol x_0) = sum_i in N_0 lambda_i z_i","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Note that the natural neighbour coordinates property only works for points in the convex hull of boldsymbol X (otherwise boldsymbol lambda is not convex), hence the restriction boldsymbol x_0 in mathcal C(boldsymbol X).","category":"page"},{"location":"interpolation_math/#Some-Local-Coordinates","page":"Interpolation Details","title":"Some Local Coordinates","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Let us now define all the coordinates we provide in this package.","category":"page"},{"location":"interpolation_math/#Nearest-Neighbours","page":"Interpolation Details","title":"Nearest Neighbours","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"To represent a point boldsymbol x_0, we can use what are known as nearest neighbour coordinates, which simply assigns a weight of 1 to the generator of the tile that boldsymbol x_0 is in:","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"lambda_i^textNEAR = begincases 1  boldsymbol x_0 in mathcal V_i  0  textotherwise endcases","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"The resulting scatterd data interpolant f^textNEAR is then just ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"f^textNEAR(boldsymbol x) = z_i ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"where boldsymbol x in mathcal V_i. An example of what this interpolant looks like is given below.","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"<figure>\n    <img src='../figures/fnear_example.png', alt='Nearest Neighbour Interpolation'><br>\n</figure>","category":"page"},{"location":"interpolation_math/#Laplace-Coordinates","page":"Interpolation Details","title":"Laplace Coordinates","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Here we introduce Laplace coordinates, also known as non-Sibsonian coordinates. To define these coordinates, let us take some tessellation mathcal V(boldsymbol X) and see what happens when we add a point into it.","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"<figure>\n    <img src='../figures/new_tile.png', alt='Tessellation with a new point'><br>\n</figure>","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"In the figure above, the tiles with the black boundaries and no fill are the tiles of the original tessellation, and we show the tile that would be created by some query point boldsymbol x_0 (the magenta point) with a blue tile. We see that the insertion of boldsymbol x_0 into the tessellation has intersected some of the other tiles, in particular it has modified only the tiles corresponding to its natural neighbours in N(\\boldsymbol x_0).","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"For a given generator boldsymbol x_i in N(boldsymbol x_0), we see that there is a corresponding blue line passing through its tile. Denote this blue line by mathcal F_0i, and let r_i = boldsymbol x_0 - boldsymbol x_i. With this definition, we define ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"lambda_i^textLAP = frachatlambda_i^textLAPsum_j in N_0 hatlambda_j^textLAP quad hatlambda_i^textLAP = fracell(mathcal F_0i)r_i","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"where ell(mathcal F_0i) is the length of the facet mathcal F_0i. In particular, hatlambda_i^textLAP is the ratio of the blue line inside the tile and the distance between the generator boldsymbol x_i and the query point boldsymbol x_0. These coordinates are continuous in mathcal C(boldsymbol X) with derivative discontinuities at the data sites boldsymbol X. The resulting interpolant f^textLAP inherits these properties, where ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"f^textLAP(boldsymbol x_0) = sum_i in N_0 lambda_i^textLAPz_i","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"This interpolant has linear precision, meaning it reproduces linear functions.","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"An example of what this interpolant looks like is given below.","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"<figure>\n    <img src='../figures/flap_example.png', alt='Laplace Interpolation'><br>\n</figure>","category":"page"},{"location":"interpolation_math/#Sibson-Coordinates","page":"Interpolation Details","title":"Sibson Coordinates","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Now we consider Sibson's coordinates. These coordinates are similar to Laplace's coordinates, except we consider the areas rather than lengths for the facets. In particular, let us return to the figure above, reprinted below for convenience:","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"<figure>\n    <img src='../figures/new_tile.png', alt='Tessellation with a new point'><br>\n</figure>","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"The idea is to consider how much area this new blue tile \"steals\" from the tiles of its natural neighbours. Based on the following identity (Sibson, 1980),","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"textArea(mathcal V_boldsymbol x_0) boldsymbol x = sum_i in N_0 textArea(mathcal V_boldsymbol x cap mathcal V_boldsymbol x_i^boldsymbol x_0)boldsymbol x_i","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"where mathcal V_boldsymbol x_0 is the new tile shown in blue, and mathcal V_boldsymbol x_i^boldsymbol x_0 is the tile associated with boldsymbol x_i in the original tessellation, i.e. prior to the insertion of boldsymbol x_0, we define Sibson's coordinates as ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"lambda_i^textSIB = frachatlambda_i^textSIBsum_j in N_0 hatlambda_j^textSIB quad hatlambda_i^textSIB = textArea(mathcal V_boldsymbol x_0 cap mathcal V_boldsymbol x_i^boldsymbol x_0)","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"A clearer way to write this is as ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"lambda_i^textSIB = fracA(boldsymbol x_i)A(boldsymbol x)","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"where A(boldsymbol x_i) is the area of the intersection between the original tile for boldsymbol x_i and the new tile at boldsymbol x_0, and A(boldsymbol x) is the total area of the new blue tile. These coordinates are C^1 continuous in mathcal C(boldsymbol X) setminus boldsymbol X, with derivative discontinuities at the data sites, and so too is the interpolant ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"f^textSIB(boldsymbol x_0) = sum_i in N_0 lambda_i^textSIBz_i","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"We may also use f^textSIB0 and lambda_i^textSIB0 rather than f^textSIB and lambda_i^textSIB, respectively. ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"This interpolant has linear precision, meaning it reproduces linear functions.","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"An example of what this interpolant looks like is given below.","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"<figure>\n    <img src='../figures/fsib0_example.png', alt='Sibson Interpolation'><br>\n</figure>","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Our implementation of these coordinates follows this article with some simple modifications.","category":"page"},{"location":"interpolation_math/#Triangle-Coordinates","page":"Interpolation Details","title":"Triangle Coordinates","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Now we define triangle coordinates. These are not actually natural coordinates (they are not continuous in boldsymbol x), but they just give a nice comparison with other methods. The idea is to interpolate based on the barycentric coordinates of the triangle that the query point is in, giving rise to a piecewise linear interpolant over mathcal C(boldsymbol X).","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Let us take our query point boldsymbol x=(xy) and suppose it is in some triangle V with coordinates boldsymbol x_1 = (x_1y_1), boldsymbol x_2 = (x_2y_2), and boldsymbol x_3=(x_3y_3). We can then define:","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"beginalign*\nDelta = (y_2-y_3)(x_1-x_3)+(x_3-x_2)(y_1-y_3) \nlambda_1 = frac(y_2-y_3)(x-x_3)+(x_3-x_2)(y-y_3)Delta \nlambda_2 = frac(y_3-y_1)(x-x_3) + (x_1-x_3)(y-y_3)Delta \nlambda_3 = 1-lambda_1-lambda_2\nendalign*","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"With these definitions, our interpolant is ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"f^textTRI(boldsymbol x) = lambda_1z_1 + lambda_2z_2 + lambda_3z_3","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"(Of course, the subscripts would have to be modified to match the actual indices of the points rather than assuming them to be boldsymbol x_1, boldsymbol x_2, and boldsymbol x_3.) This is the same interpolant used in FiniteVolumeMethod.jl.","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"An example of what this interpolant looks like is given below.","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"<figure>\n    <img src='../figures/ftri_example.png', alt='Triangle Interpolation'><br>\n</figure>","category":"page"},{"location":"interpolation_math/#Smooth-Interpolation","page":"Interpolation Details","title":"Smooth Interpolation","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"All the derived interpolants above are not differentiable at the data sites. Here we describe some interpolants that are differentiable at the data sites. ","category":"page"},{"location":"interpolation_math/#Sibson's-C1-Interpolant","page":"Interpolation Details","title":"Sibson's C^1 Interpolant","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Sibson's C^1 interpolant, which we call Sibson-1 interpolation, extends on Sibon's coordinates above, also called Sibson-0 coordinates, is C^1 at the data sites. A limitation of it is that it requires an estimate of the gradient boldsymbol nabla_i at the data sites boldsymbol x_i, which may be estimated using the derivative generation techniques describd in the sidebar. ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Following Bobach's thesis or Flötotto's thesis, the Sibson-1 interpolant f^textSIB1 is a linear combination of f^textSIB0 equiv f^textSIB and another interpolant xi. We define:","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"beginalign*\nr_i = boldsymbol x_0-boldsymbol x_i \ngamma_i = fraclambda_i^textSIB0r_i \nzeta_i = z_i + (boldsymbol x_0 - boldsymbol x_i)^Tboldsymbolnabla_i \nzeta = fracsum_iin N_0 gamma_izeta_isum_iin N_0 gamma_i \nalpha = fracsum_i in N_0 lambda_i^textSIB0r_isum_i in N_0 gamma_i \nbeta = sum_i in N_0 lambda_i^textSIB0r_i^2\nendalign*","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Our interpolant is then defined by ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"f^textSIB1(boldsymbol x_0) = fracalpha f^textSIB0 + betazetaalpha + beta","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"This interpolant exactly reproduces spherical quadratics boldsymbol x mapsto mu(boldsymbol x - boldsymbol a)^T(boldsymbol x - boldsymbol a).","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"An example of what this interpolant looks like is given below.","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"<figure>\n    <img src='../figures/fsib1_example.png', alt='Sibson-1 Interpolation'><br>\n</figure>","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Notice that the peak of the function is much smoother than it was in the other interpolant examples.","category":"page"},{"location":"interpolation_math/#Farin's-C1-Interpolant","page":"Interpolation Details","title":"Farin's C^1 Interpolant","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Farin's C^1 interpolant, introduced by Farin (1990), is another interpolant with C^1 continuity at the data sites provided we have estimates of the gradients boldsymbol nabla_i at the data sites (see the sidebar for derivative generation methods), and also makes use of the Sibson-0 coordinates. Typically these coordinates are described in the language of Bernstein-Bézier simplices (as in Bobach's thesis or Flötotto's thesis and Farin's original paper), this language makes things more complicated than they need to be. Instead, we describe the interpolant using symmetric homogeneous polynomials, as in Hiyoshi and Sugihara (2004, 2007). See the references mentioned above for a derivation of the interpolant we describe below.","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Let boldsymbol x_0 be some point in mathcal C(boldsymbol X) and let N_0 be the natural neighbourhood around boldsymbol x_0. We let the natural coordinates be given by Sibson's coordinates boldsymbol lambda = (lambda_1ldotslambda_n) with corresponding natural neighbours boldsymbol x_1ldotsboldsymbol x_n (rearranging the indices accordingly to avoid using e.g. i_1ldots i_n), where n = N_0. We define a homogeneous symmetric polynomial ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"f(boldsymbol x_0) = sum_i in N_0sum_j in N_0sum_k in N_0 f_ijklambda_ilambda_jlambda_k","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"where the coefficients f_ijk are symmetric so that they can be uniquely determined. We define z_i j = boldsymbol nabla_i^T overrightarrowboldsymbol x_iboldsymbol x_j, where boldsymbol nabla_i is the estimate of the gradient at boldsymbol x_i in N(boldsymbol x_0) subset boldsymbol X and overrightarrowboldsymbol x_iboldsymbol x_j = boldsymbol x_j - boldsymbol x_i. Then, define the coefficients (using symmetry to permute the indices to the standard forms below):","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"beginalign*\nf_iii = z_i \nf_iij = z_i + frac13z_ij  \nf_ijk = fracz_i+z_j+z_k3 + fracz_ij+z_ik+z_ji+z_jk+z_ki+z_kj12\nendalign*","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"where all the i, j, and k are different. The resulting interpolant f is Farin's C^1 interpolant, f^textFAR = f, and has quadratic precision so that it reproduces quadratic polynomials.","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Let us describe how we actually evaluate sum_i in N_0sum_j in N_0sum_k in N_0 f_ijklambda_ilambda_jlambda_k efficiently. Write this as","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"f^textFAR(boldsymbol x_0) = sum_1 leq i j k leq n f_ijklambda_ilambda_jlambda_k","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"This looks close to the definition of a complete homogeneous symetric polynomial. This page shows the identity","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"sum_1 leq i leq j leq k leq n X_iX_kX_j = sum_1 leq i j k leq n fracm_im_jm_k3X_iX_jX_k","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"where m_ell is the multiplicity of X_ell in the summand, e.g. if the summand is X_i^2X_k then m_i=2 and m_k = 1. Thus, transforming the variables accordingly, we can show that ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"f^textFAR(boldsymbol x_0) = 6underbracesum_i=1^nsum_j=i^nsum_k=j^n_sum_1 leq i leq j leq k leq n tilde f_ijklambda_ilambda_jlambda_k","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"where tilde f_iii = f_iii3 = f_iii6, tilde f_iij = f_iij2, and tilde f_ijk = f_ijk. This is the implementation we use.","category":"page"},{"location":"interpolation_math/#Hiyoshi's-C2-Interpolant","page":"Interpolation Details","title":"Hiyoshi's C^2 Interpolant","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Hiyoshi's C^2 interpolant is similar to Farin's C^1 interpolant, except now we have C^2 continuity at the data sites and we now, in addition to requiring estimates of the gradients boldsymbol nabla_i at the data sites, require estimates of the Hessians boldsymbol H_i at the data sites (see the sidebar for derivative generation methods). As with Farin's C^1 interpolant, we use the language of homogeneous symmetric polynomials rather than Bernstein-Bézier simplices in what follows. There are two definitions of Hiyoshi's C^2 interpolant, the first being given by Hiyoshi and Sugihara (2004) and described by Bobach, and the second given three years later again by  Hiyoshi and Sugihara (2007). We use the 2007 definition - testing shows that they are basically the same, anyway.","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Like in the previous section, w let boldsymbol x_0 be some point in mathcal C(boldsymbol X) and let N_0 be the natural neighbourhood around boldsymbol x_0. We let the natural coordinates be given by Sibson's coordinates boldsymbol lambda = (lambda_1ldotslambda_n) with corresponding natural neighbours boldsymbol x_1ldotsboldsymbol x_n (rearranging the indices accordingly to avoid using e.g. i_1ldots i_n), where n = N_0. We define ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"z_i j = boldsymbol nabla_i^Toverrightarrowboldsymbol x_iboldsymbol x_j qquad z_i jk = overrightarrowboldsymbol x_iboldsymbol x_j^Tboldsymbol H_ioverrightarrowboldsymbol x_iboldsymbol x_k","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Hiyoshi's C^2 interpolant, written f^textHIY (or later f^textHIY2, if ever we can get Hiyoshi's C^k interpolant on mathcal C(boldsymbol X) setminus boldsymbol X implemented –- see Hiyoshi and Sugihara (2000, 2002), Bobach, Bertram, Umlauf (2006), and Chapter 3.2.5.5 and Chapter 5.5. of Bobach's thesis), is defined by the homogeneous symmetric polynomial","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"f^textHIY(boldsymbol x_0) = sum_1 leq ijkellm leq n f_ijkell mlambda_ilambda_jlambda_klambda_elllambda_m","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"where we define the coefficients (using symmetry to permute the indices to the standard forms below):","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"beginalign*\nf_iiiii = z_i \nf_iiiij = z_i + frac15z_ij \nf_iiijj = z_i + frac25z_ij + frac120z_ijj \nf_iiijk = z_i + frac15left(z_i j + z_i kright) + frac120z_i jk \nf_iijjk = frac1330left(z_i + z_jright) + frac215z_k + frac19left(z_i j + z_j iright) + frac790left(z_i k + z_j kright) + frac245left(z_k i + z_k jright) + frac145left(z_i jk + z_j ik + z_k ijright) \nf_iijkell = frac12z_i + frac16left(z_j + z_k + z_ellright) + frac790left(z_i j + z_i k + z_i ellright) + frac245left(z_j i + z_k i + z_ell iright) + frac130left(z_j k + z_j ell + z_k j + z_k ell + z_ell j + z_j kright) \n+ frac190left(z_i jk + z_i jell + z_i kellright) + frac190left(z_j ik + z_j iell + z_k ij + z_k iell + z_ell ij + z_ell ikright) + frac1180left(z_j kell + z_k jell + z_ell jkright) \nf_ijkell m = frac15left(z_i + z_j + z_k + z_ell + z_mright) \n+ frac130left(z_i j + z_i k + z_i ell + z_i m + z_j i + cdots + z_m ellright) \n+ frac1180left(z_i jk + z_i jell + z_i jm + z_i kell + z_i km + z_i ell m + z_j iell + cdots + z_mkellright)\nendalign*","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"where all the i, j, k, ell, and m are different. To evaluate f^textHIY, we use the same relationship between f^textHIY and complete homogeneous symmetric polynomials to write","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"f^textHIY(boldsymbol x_0) = 120sum_1 leq i leq j leq k leq ell leq m leq n tilde f_ijk ell m lambda_ilambda_jlambda_klambda_ell lambda_m","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"where tilde f_iiiii = f_iiiii5 = f_iiiii120, tilde f_iiiij = f_iiiij24, tilde f_iijjj = f_iijjj12, tilde f_iijjk = f_iijjk4, tilde f_iijkell = f_iijkell2, and tilde f_ijkell m = f_ijkell m.","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"This interpolant has cubic precision, meaning it can recover cubic polynomials. Note that this sum has","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"sum_i=1^nsum_j=i^nsum_k=j^nsum_ell=k^nsum_m=k^n 1 = fracn^5120 + fracn^412 + cdots = mathcal O(n^5)","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"terms, which could cause issues with many natural neighbours. For example, with n = 20 we have n^5 = 3200000. In fact, as discussed in Section 6.5 of Bobach's thesis, more than 150 million operations could be required with n = 20. We discuss benchmark results in the comparison section of the sidebar.","category":"page"},{"location":"interpolation_math/#Regions-of-Influence","page":"Interpolation Details","title":"Regions of Influence","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"The region of influence for the natural neighbour coordinates associated with a point boldsymbol x_i is the interior the union of all circumcircles coming from the triangles of the underlying triangulation that pass through boldsymbol x_i. We can visualise this for the coordinates we define above below. (this region of influence definition not necessarily generalise to the triangle and nearest neighbour coordinates, but we still compare them).","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"We take a set of data sites in -1 1^2 such that all function values are zero except for z_1 = 0 with boldsymbol x_1 = boldsymbol 0. Using this setup, we obtain the following results (see also Figure 3.6 of Bobach's thesis linked previously):","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"<figure>\n    <img src='../figures/influence.png', alt='Region of Influence'><br>\n</figure>","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"We can indeed see the effect of the region of influence about this single point boldsymbol x_1. Note also that f^textSIB1 is much smoother than the others.","category":"page"},{"location":"interpolation_math/#Extrapolation","page":"Interpolation Details","title":"Extrapolation","text":"","category":"section"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"An important consideration is extrapolation. Currently, all the methods above assume that the query point boldsymbol x_0 is in mathcal C(boldsymbol X), and the interpolation near the boundary of mathcal C(boldsymbol X) often has some weird effects. There are many approaches available for extrapolation, such as with ghost points, although these are not implemented in this package (yet!).","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"The approach we take for any point outside of mathcal C(boldsymbol X), or on partialmathcal C(boldsymbol X), is to find the ghost triangle that boldsymbol x_0 is in (ghost triangles are defined here in the DelaunayTriangulation.jl documentation), which will have some boundary edge boldsymbol e_ij. (Similarly, if boldsymbol x_0 in partial mathcal C(boldsymbol X), boldsymbol e_ij is the boundary edge that it is on.) We then simply use two-point interpolation, letting ","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"f(boldsymbol x_0) approx lambda_iz_i + lambda_jz_j","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"where lambda_i = 1-t, lambda_j = t, ell = x_i - boldsymbol x_j, and t = (x_0 - x_i)(x_j - x_i) + (y_0 - y_i)(y_j - y_i)ell^2. Note also that in this definition of t we have projected boldsymbol x_0 onto the line through boldsymbol x_i and boldsymbol x_j – this projection is not necessarily on boldsymbol e_ij, though, so t will not always be in 0 1, meaning the coordinates are not guaranteed to be (and probably won't be) convex.","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"This extrapolation will not always be perfect, but it is good enough until we implement more sophisticated methods. If you want to disable this approach, just use the project = false keyword argument when evaluating your interpolant.","category":"page"},{"location":"interpolation_math/","page":"Interpolation Details","title":"Interpolation Details","text":"Similarly, if you have points defining a boundary of some domain that isn't necessarily convex, the function identify_exterior_points may be useful to you, provided you have represented your boundary as defined here in DelaunayTriangulation.jl. See the Switzerland example in the sidebar for more information.","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"CurrentModule = NaturalNeighbours","category":"page"},{"location":"swiss/#Switzerland-Elevation-Data","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"","category":"section"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"Here we consider a more involved example, constructing an interpolant over elevation data of Switzerland. We use data from geoBoundaries who credits OpenStreetMap for the data (available under an Open Database License). The data is available as a gist, which was generated with the following R code (you don't need to run this code - we will download it directly from the gist soon):","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"## Install and load the packages\n#install.packages(c(\"remotes\", \"sf\", \"raster\", \"elevatr\", \"dplyr\", \"magrittr\"))\n#install.packages(c(\"dplyr\", \"magrittr\"))\n#remotes::install_gitlab(\"dickoa/rgeoboundaries\")\nlibrary(rgeoboundaries)\nlibrary(sf)\nlibrary(raster)\nlibrary(elevatr)\n#library(dplyr)\n#library(magrittr)\n\n## Get the elevation and polygon data \nswiss_bound <- rgeoboundaries::geoboundaries(\"Switzerland\")\nelevation_data_rast <- elevatr::get_elev_raster(locations = swiss_bound, z = 7, clip = \"locations\")\nboundary_coords <- rasterToPolygons(elevation_data_rast > -Inf, dissolve = TRUE) # https://gis.stackexchange.com/a/187800\nelevation_data_xy <- as.data.frame(elevation_data_rast, xy = TRUE)\ncolnames(elevation_data_xy)[3] <- \"elevation\"\nelevation_data_xy <- elevation_data_xy[complete.cases(elevation_data_xy), ]\nall_polygons = boundary_coords@polygons[[1]]@Polygons\n\n## Inspect all the polygons\n#conv = function(polygon, id) {\n#  coords = polygon@coords \n#  dir = polygon@ringDir\n#  hole = polygon@hole\n#  df = tibble(x = coords[, 1], y = coords[, 1], dir = polygon@ringDir, hole = polygon@hole, id = id)\n#}\n#polygon_df = vector('list', length(all_polygons))\n#for (i in seq_along(polygon_df)) {\n#  polygon_df[[i]] = conv(all_polygons[[i]], i)\n#}\n#polygon_df %<>% bind_rows(.id = \"column_label\")\n# ^ After inspecting these results, the only polygon of interest is the first one.\n\npolygons = all_polygons[[1]]@coords\nx = elevation_data_xy[, 1]\ny = elevation_data_xy[, 2]\nz = elevation_data_xy[, 3]\nbnd_x = polygons[, 1]\nbnd_y = polygons[, 2]","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"For this example, load the following packages:","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"using NaturalNeighbours\nusing CairoMakie\nusing DelaunayTriangulation\nusing DelimitedFiles\nusing Downloads\nusing StableRNGs\nusing StatsBase","category":"page"},{"location":"swiss/#Downloading-the-Data","page":"Switzerland Elevation Data","title":"Downloading the Data","text":"","category":"section"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"To start, let us download and setup the data. We need to get the data sites, the elevation values, and also the boundary points.","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"data_url = \"https://gist.githubusercontent.com/DanielVandH/13687b0918e45a416a5c93cd52c91449/raw/a8da6cdc94859fd66bcff85a2307f0f9cd57a18c/data.txt\"\nboundary_url = \"https://gist.githubusercontent.com/DanielVandH/13687b0918e45a416a5c93cd52c91449/raw/a8da6cdc94859fd66bcff85a2307f0f9cd57a18c/boundary.txt\"\ndata_dir = Downloads.download(data_url)\nboundary_dir = Downloads.download(boundary_url)\ndata = readdlm(data_dir, skipstart=6)\ndata[:, 3] ./= 1000.0 # m -> km\nboundary = readdlm(boundary_dir, skipstart=6)\ngood_elevation = findall(≥(0), @view data[:, 3])\ndata = @views data[good_elevation, :]\ndata_sites = [(data[i, 1], data[i, 2]) for i in axes(data, 1)]\nelevation_data = @views data[:, 3]\nboundary_points = [(boundary[i, 1], boundary[i, 2]) for i in axes(boundary, 1)]","category":"page"},{"location":"swiss/#Downsampling-and-Setting-up-the-Data-for-Plotting","page":"Switzerland Elevation Data","title":"Downsampling and Setting up the Data for Plotting","text":"","category":"section"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"We now setup the data for plotting. We want to use tricontourf!, so we need to get a triangulation of the data. If we just let Makie compute the triangulation, it will be unconstrained and won't show us the actual data properly. So, some extra work is required. Furthermore, the boundary_points do not actually store a subset of the points from data_sites, so we can't just do e.g. indexin(boundary_points, data_sites) to get the associated boundary indices, so we instead find the closest data site to each boundary point.","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"function nearest_tuple(q, data)\n    δ = Inf\n    nearest_idx = 0\n    qx, qy = getxy(q)\n    for (i, p) in pairs(data)\n        px, py = getxy(p)\n        δ₁ = (qx - px)^2 + (qy - py)^2\n        if δ₁ < δ\n            δ = δ₁\n            nearest_idx = i\n        end\n    end\n    return nearest_idx\nend\nfunction update_boundary(boundary_points, data_sites)\n    boundary_nodes = map(q -> nearest_tuple(q, data_sites), boundary_points)\n    unique!(boundary_nodes)\n    push!(boundary_nodes, boundary_nodes[begin])\n    reverse!(boundary_nodes) # so that the boundary is traversed clockwise\n    boundary_points = data_sites[boundary_nodes]\n    return boundary_points, data_sites, boundary_nodes\nend\nboundary_points, data_sites, boundary_nodes = update_boundary(boundary_points, data_sites)\ntri = triangulate(data_sites, boundary_nodes=boundary_nodes)\ntriangles = [T[j] for T in each_solid_triangle(tri), j in 1:3]","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"Next, before, we plot, let us downsample the data. We do this since the data set is quite large, so when we interpolate it'll be useful to have fewer data points for the purpose of this example.","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"rng = StableRNG(123)\ndesample_idx = sample(rng, axes(data, 1), 5000, replace=false)\nds_data = data[desample_idx, :]\nds_data_sites = [(ds_data[i, 1], ds_data[i, 2]) for i in axes(ds_data, 1)]\nds_elevation_data = @views ds_data[:, 3]\nds_boundary_points, ds_data_sites, ds_boundary_nodes = update_boundary(boundary_points, ds_data_sites)\nreverse!(ds_boundary_nodes) # so that the boundary is traversed clockwise\nds_tri = triangulate(ds_data_sites, boundary_nodes=ds_boundary_nodes)\nds_triangles = [T[j] for T in each_solid_triangle(ds_tri), j in 1:3]","category":"page"},{"location":"swiss/#Looking-at-the-Data","page":"Switzerland Elevation Data","title":"Looking at the Data","text":"","category":"section"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"Now let's look at the data.","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"colorrange = (0, 4)\nlevels = LinRange(colorrange..., 40)\nfig = Figure(fontsize=24)\nax1 = Axis3(fig[1, 1], xlabel=\"Longitude\", ylabel=\"Latitude\", zlabel=\"Elevation (km)\", width=600, height=400, azimuth=0.9, title=\"(a): Original height data (n = $(length(elevation_data)))\", titlealign=:left)\nmesh!(ax1, data, triangles, color=elevation_data, colorrange=colorrange)\nax2 = Axis(fig[1, 2], xlabel=\"Longitude\", ylabel=\"Latitude\", width=600, height=400, title=\"(b): Original height data (n = $(length(elevation_data)))\", titlealign=:left)\ntf = tricontourf!(ax2, data[:, 1], data[:, 2], elevation_data, color=elevation_data, triangulation=triangles', levels=levels)\n\nax3 = Axis3(fig[2, 1], xlabel=\"Longitude\", ylabel=\"Latitude\", zlabel=\"Elevation (km)\", width=600, height=400, azimuth=0.9, title=\"(c): Downsampled height data (n = $(length(ds_elevation_data)))\", titlealign=:left)\nmesh!(ax3, ds_data, ds_triangles, color=ds_elevation_data, colorrange=colorrange)\nax4 = Axis(fig[2, 2], xlabel=\"Longitude\", ylabel=\"Latitude\", width=600, height=400, title=\"(d): Downsampled height data (n = $(length(ds_elevation_data)))\", titlealign=:left)\ntricontourf!(ax4, ds_data[:, 1], ds_data[:, 2], ds_elevation_data, color=ds_elevation_data, triangulation=ds_triangles', levels=levels)\nColorbar(fig[1:2, 3], tf)\nresize_to_layout!(fig)","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"<figure>\n    <img src='../figures/swiss_heights.png', alt'Switzerland Data'><br>\n</figure>","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"We see that the downsampled data isn't that much different, despite having n = 5000 points rather than n = 220175 as in the original data set. Of course, the boundary has been trimmed a bit (if we really cared, we probably wouldn't have downsampled the boundary, but instead only downsampled the interior points - not relevant for this example).","category":"page"},{"location":"swiss/#Interpolating","page":"Switzerland Elevation Data","title":"Interpolating","text":"","category":"section"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"Now let's define and evaluate our interpolant.","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"## Define the interpolant \ninterpolant = interpolate(ds_data_sites, ds_elevation_data; derivatives=true)\n\n## Evaluate the interpolant \na, b, c, d = DelaunayTriangulation.polygon_bounds(ds_data_sites, ds_boundary_nodes)\nnx = 250\nny = 250\nxg = LinRange(a, b, nx)\nyg = LinRange(c, d, ny)\nx = [xg[i] for i in 1:nx, j in 1:ny] |> vec\ny = [yg[j] for i in 1:nx, j in 1:ny] |> vec\n\nsibson_vals = interpolant(x, y; method=Sibson(), parallel=true)\nsibson_1_vals = interpolant(x, y; method=Sibson(1), parallel=true)\nlaplace_vals = interpolant(x, y; method=Laplace(), parallel=true)\ntriangle_vals = interpolant(x, y; method=Triangle(), parallel=true)\nnearest_vals = interpolant(x, y; method=Nearest(), parallel=true)\nfarin_vals = interpolant(x, y; method=Farin(), parallel=true)\nhiyoshi_vals = interpolant(x, y; method=Hiyoshi(2), parallel=true)","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"Let's look at our results for each of these methods.","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"query_tri = triangulate([x'; y'])\nquery_triangles = [T[j] for T in each_solid_triangle(query_tri), j in 1:3]\nfunction plot_results!(fig, i1, j1, i2, j2, x, y, xg, yg, vals, title1, title2, query_triangles, query_tri, a, b, c, d, e, f, nx, ny)\n    ax = Axis3(fig[i1, j1], xlabel=\"Longitude\", ylabel=\"Latitude\", zlabel=\"Elevation (km)\", width=600, height=400, azimuth=0.9, title=title1, titlealign=:left)\n    m = mesh!(ax, hcat(x, y, vals), query_triangles, color=vals, colorrange=colorrange)\n    xlims!(ax, a, b)\n    ylims!(ax, c, d)\n    zlims!(ax, e, f)\n    ax = Axis(fig[i2, j2], xlabel=\"Longitude\", ylabel=\"Latitude\", width=600, height=400, title=title2, titlealign=:left)\n    contourf!(ax, xg, yg, reshape(vals, (nx, ny)), color=vals, levels=levels)\n    lines!(ax, [get_point(query_tri, i) for i in get_convex_hull_indices(query_tri)], color=:red, linewidth=4, linestyle=:dash)\n    lines!(ax, ds_boundary_points, color=:white, linewidth=4)\n    xlims!(ax, a, b)\n    ylims!(ax, c, d)\n    return m\nend\nfunction plot_results(sibson_vals, sibson_1_vals, laplace_vals, triangle_vals, nearest_vals, farin_vals, hiyoshi_vals, query_triangles, interpolant, a, b, c, d, e, f, nx, ny, data, triangles, elevation_data)\n    fig = Figure(fontsize=24)\n    m1 = plot_results!(fig, 1, 1, 1, 2, x, y, xg, yg, sibson_vals, \"(a): Sibson\", \"(b): Sibson\", query_triangles, interpolant.triangulation, a, b, c, d, e, f, nx, ny)\n    m2 = plot_results!(fig, 1, 3, 1, 4, x, y, xg, yg, sibson_1_vals, \"(c): Sibson-1\", \"(d): Sibson-1\", query_triangles, interpolant.triangulation, a, b, c, d, e, f, nx, ny)\n    m3 = plot_results!(fig, 2, 1, 2, 2, x, y, xg, yg, laplace_vals, \"(e): Laplace\", \"(f): Laplace\", query_triangles, interpolant.triangulation, a, b, c, d, e, f, nx, ny)\n    m4 = plot_results!(fig, 2, 3, 2, 4, x, y, xg, yg, triangle_vals, \"(g): Triangle\", \"(h): Triangle\", query_triangles, interpolant.triangulation, a, b, c, d, e, f, nx, ny)\n    m5 = plot_results!(fig, 3, 1, 3, 2, x, y, xg, yg, nearest_vals, \"(i): Nearest\", \"(j): Nearest\", query_triangles, interpolant.triangulation, a, b, c, d, e, f, nx, ny)\n    m6 = plot_results!(fig, 3, 3, 3, 4, x, y, xg, yg, farin_vals, \"(k): Farin\", \"(ℓ): Farin\", query_triangles, interpolant.triangulation, a, b, c, d, e, f, nx, ny)\n    m7 = plot_results!(fig, 4, 1, 4, 2, x, y, xg, yg, hiyoshi_vals, \"(m): Hiyoshi\", \"(n): Hiyoshi\", query_triangles, interpolant.triangulation, a, b, c, d, e, f, nx, ny)\n    ax = Axis3(fig[4, 3], xlabel=\"Longitude\", ylabel=\"Latitude\", zlabel=\"Elevation (km)\", width=600, height=400, azimuth=0.9, title=\"(k): Original height data\", titlealign=:left)\n    mesh!(ax, data, triangles, color=elevation_data, colorrange=(0, 4))\n    xlims!(ax, a, b)\n    ylims!(ax, c, d)\n    zlims!(ax, e, f)\n    ax = Axis(fig[4, 4], xlabel=\"Longitude\", ylabel=\"Latitude\", width=600, height=400, title=\"(o): Original height data\", titlealign=:left)\n    tricontourf!(ax, data[:, 1], data[:, 2], elevation_data, color=elevation_data, triangulation=triangles', levels=levels)\n    xlims!(ax, a, b)\n    ylims!(ax, c, d)\n    Colorbar(fig[1:4, 5], m1)\n    resize_to_layout!(fig)\n    return fig\nend\ne, f = 0.0, 4.5\nfig = plot_results(sibson_vals, sibson_1_vals, laplace_vals, triangle_vals, nearest_vals, farin_vals, hiyoshi_vals, query_triangles, interpolant, a, b, c, d, e, f, nx, ny, data, triangles, elevation_data)","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"<figure>\n    <img src='../figures/swiss_heights_interpolated.png', alt'Switzerland Data Interpolated'><br>\n</figure>","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"We see that the results are pretty similar across the methods except for Nearest(). We could compute the errors between the interpolant and the points that we removed from the dataset to quantify this better, but we won't do that –- we're not intending to a comprehensive analysis here.","category":"page"},{"location":"swiss/#Eliminating-Points-Outside-of-the-Convex-Hull","page":"Switzerland Elevation Data","title":"Eliminating Points Outside of the Convex Hull","text":"","category":"section"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"One issue with the interpolant is that the extrapolated results are distracting. Let's set project=false to remove values outside of the convex hull of our data sites.","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"sibson_vals_p = interpolant(x, y; method=Sibson(), parallel=true, project=false)\nsibson_1_vals_p = interpolant(x, y; method=Sibson(1), parallel=true, project=false)\nlaplace_vals_p = interpolant(x, y; method=Laplace(), parallel=true, project=false)\ntriangle_vals_p = interpolant(x, y; method=Triangle(), parallel=true, project=false)\nnearest_vals_p = interpolant(x, y; method=Nearest(), parallel=true, project=false)\nfarin_vals_p = interpolant(x, y; method=Farin(), parallel=true, project=false)\nhiyoshi_vals_p = interpolant(x, y; method=Hiyoshi(2), parallel=true, project=false)\nfig = plot_results(sibson_vals_p, sibson_1_vals_p, laplace_vals_p, triangle_vals_p, nearest_vals_p, farin_vals_p, hiyoshi_vals_p, query_triangles, interpolant, a, b, c, d, e, f, nx, ny, data, triangles, elevation_data)","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"<figure>\n    <img src='../figures/swiss_heights_interpolated_projected.png', alt'Switzerland Data Interpolated without Projection'><br>\n</figure>","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"Of course, this is still not perfect because Switzerland is not convex! There's still points being extrapolated, and we have to handle this manually. ","category":"page"},{"location":"swiss/#Eliminating-Points-Outside-of-Switzerland","page":"Switzerland Elevation Data","title":"Eliminating Points Outside of Switzerland","text":"","category":"section"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"The function we need is identify_exterior_points, which we use together with a representation of the boundary of Switzerland (hence why we got the boundary nodes earlier). We replace all exterior values with Inf so that they don't get plotted (using NaN leads to issues with surface!'s shading for some reason).","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"exterior_idx = identify_exterior_points(x, y, ds_data_sites, ds_boundary_nodes)\nsibson_vals_p[exterior_idx] .= Inf\nsibson_1_vals_p[exterior_idx] .= Inf\nlaplace_vals_p[exterior_idx] .= Inf\ntriangle_vals_p[exterior_idx] .= Inf\nnearest_vals_p[exterior_idx] .= Inf\nfarin_vals_p[exterior_idx] .= Inf\nhiyoshi_vals_p[exterior_idx] .= Inf\nfig = plot_results(sibson_vals_p, sibson_1_vals_p, laplace_vals_p, triangle_vals_p, nearest_vals_p, farin_vals_p, hiyoshi_vals_p, query_triangles, interpolant, a, b, c, d, e, f, nx, ny, data, triangles, elevation_data)","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"<figure>\n    <img src='../figures/swiss_heights_interpolated_projected_boundary.png', alt'Switzerland Data Interpolated Complete'><br>\n</figure>","category":"page"},{"location":"swiss/","page":"Switzerland Elevation Data","title":"Switzerland Elevation Data","text":"Perfect!","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"CurrentModule = NaturalNeighbours","category":"page"},{"location":"interpolation/#Interpolation-Example","page":"Interpolation","title":"Interpolation Example","text":"","category":"section"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"Let us give an example of how interpolation can be performed. We consider the function","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"f(x y) = frac19lefttanhleft(9y-9xright) + 1right","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"First, let us generate some data.","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"using NaturalNeighbours \nusing CairoMakie \nusing StableRNGs \n\nf = (x, y) -> (1 / 9) * (tanh(9 * y - 9 * x) + 1)\n\nrng = StableRNG(123)\nx = rand(rng, 100)\ny = rand(rng, 100)\nz = f.(x, y)","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"We can now construct our interpolant. To use the Sibson-1 interpolant, we need to have gradient information, so we specify derivatives=true to make sure these get generated at the data sites.","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"itp = interpolate(x, y, z; derivatives=true)","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"This itp is now callable. Let's generate a grid to evaluate itp at.","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"xg = LinRange(0, 1, 100)\nyg = LinRange(0, 1, 100)\n_x = vec([x for x in xg, _ in yg])\n_y = vec([y for _ in xg, y in yg])","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"We use vectors for this evaluation rather than evaluating like, say, [itp(x, y) for x in xg, y in yg], since itp's evaluation will use multithreading if we give it vectors. Consider the following times (including the time to make the vectors in the vector case):","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"using BenchmarkTools\nfunction testf1(itp, xg, yg, parallel)\n    _x = vec([x for x in xg, _ in yg])\n    _y = vec([y for _ in xg, y in yg])\n    return itp(_x, _y; parallel=parallel)\nend\ntestf2(itp, xg, yg) = [itp(x, y) for x in xg, y in yg]\nb1 = @benchmark $testf1($itp, $xg, $yg, $true)\nb2 = @benchmark $testf2($itp, $xg, $yg)\nb3 = @benchmark $testf1($itp, $xg, $yg, $false)","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"julia> b1\nBenchmarkTools.Trial: 2310 samples with 1 evaluation.\n Range (min … max):  1.333 ms … 165.550 ms  ┊ GC (min … max): 0.00% … 98.28%\n Time  (median):     1.781 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   2.155 ms ±   3.446 ms  ┊ GC (mean ± σ):  3.27% ±  2.04%\n\n        ▄▆█▄▁\n  ▂▂▄▃▅▆█████▆▅▃▃▂▂▂▂▂▂▂▃▂▂▃▃▃▃▃▃▄▃▄▄▄▄▅▅▄▄▄▄▄▃▃▃▄▃▂▂▂▂▁▂▁▁▁▁ ▃\n  1.33 ms         Histogram: frequency by time        3.33 ms <\n\n Memory estimate: 254.33 KiB, allocs estimate: 146.\n\njulia> b2\nBenchmarkTools.Trial: 257 samples with 1 evaluation.\n Range (min … max):  14.790 ms … 27.120 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     18.136 ms              ┊ GC (median):    0.00%\n Time  (mean ± σ):   19.531 ms ±  4.177 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n   ▅█\n  ▆██▄▄▄▄▂▅▁▁▄▃▄▅▃▃▃▃▁▃▃▁▃▄▃▃▃▂▂▄▂▃▃▂▄▂▄▄▃▂▄▄▃▃▄▃▄▄▃▄▃▃▄▄▂▄▅▄ ▃\n  14.8 ms         Histogram: frequency by time        26.7 ms <\n\n Memory estimate: 78.17 KiB, allocs estimate: 2.\n\njulia> b3\nBenchmarkTools.Trial: 267 samples with 1 evaluation.\n Range (min … max):  14.986 ms … 27.264 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     17.354 ms              ┊ GC (median):    0.00%\n Time  (mean ± σ):   18.710 ms ±  3.750 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n   ▄█\n  ▄██▇▄▃▃▄▃▃▃▃▃▃▃▄▄▂▃▃▃▃▃▃▃▃▃▃▃▃▂▁▃▃▃▃▃▃▃▃▃▂▃▃▂▃▃▂▂▁▂▃▃▂▃▂▃▄▃ ▃\n  15 ms           Histogram: frequency by time        26.7 ms <\n\n Memory estimate: 234.67 KiB, allocs estimate: 10.","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"See that itp(_x, _y) took about 1.3 ms, while the latter two approaches both take around  15 ms. Pretty impressive given that we are evaluating 100^2 points - this is a big advantage of local interpolation making parallel evaluation so cheap and simple. This effect can be made even more clear if we use more points:","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"xg = LinRange(0, 1, 1000)\nyg = LinRange(0, 1, 1000)\nb1 = @benchmark $testf1($itp, $xg, $yg, $true)\nb2 = @benchmark $testf2($itp, $xg, $yg)\nb3 = @benchmark $testf1($itp, $xg, $yg, $false)","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"julia> b1\nBenchmarkTools.Trial: 27 samples with 1 evaluation.\n Range (min … max):  132.766 ms … 354.348 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     144.794 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   188.429 ms ±  79.396 ms  ┊ GC (mean ± σ):  0.37% ± 2.38%\n\n  ▁█▃▁\n  ████▄▄▄▁▁▁▁▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄▁▁▁▁▄▄▁▁▁▁▁▁▁▁▄▁▁▁▁▁▁▁▄▇ ▁\n  133 ms           Histogram: frequency by time          354 ms <\n\n Memory estimate: 22.91 MiB, allocs estimate: 157.\n\njulia> b2\nBenchmarkTools.Trial: 2 samples with 1 evaluation.\n Range (min … max):  2.564 s …    2.794 s  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     2.679 s               ┊ GC (median):    0.00%\n Time  (mean ± σ):   2.679 s ± 162.574 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  █                                                        █\n  █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁\n  2.56 s         Histogram: frequency by time         2.79 s <\n\n Memory estimate: 7.63 MiB, allocs estimate: 2.\n\njulia> b3\nBenchmarkTools.Trial: 2 samples with 1 evaluation.\n Range (min … max):  2.557 s …   2.624 s  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     2.590 s              ┊ GC (median):    0.00%\n Time  (mean ± σ):   2.590 s ± 46.978 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  █                                                       █\n  █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁\n  2.56 s         Histogram: frequency by time        2.62 s <\n\n Memory estimate: 22.89 MiB, allocs estimate: 10.","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"Now let's continue with the example. We compare Sibson-0 to Sibson-1 (going back to the original definitions of xg and yg with 100^2 points):","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"sib_vals = itp(_x, _y)\nsib1_vals = itp(_x, _y; method=Sibson(1))","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"Now we can plot.","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"function plot_itp(fig, x, y, vals, title, i, show_data_sites, itp, xd=nothing, yd=nothing, show_3d=true, levels=-0.1:0.05:0.3)\n    ax = Axis(fig[1, i], xlabel=\"x\", ylabel=\"y\", width=600, height=600, title=title, titlealign=:left)\n    c = contourf!(ax, x, y, vals, color=vals, colormap=:viridis, levels=levels, extendhigh=:auto)\n    show_data_sites && scatter!(ax, xd, yd, color=:red, markersize=9)\n    tri = itp.triangulation\n    ch_idx = get_convex_hull_indices(tri)\n    lines!(ax, [get_point(tri, i) for i in ch_idx], color=:white, linewidth=4)\n    if show_3d\n        ax = Axis3(fig[2, i], xlabel=\"x\", ylabel=\"y\", zlabel=L\"z\", width=600, height=600, title=\" \", titlealign=:left, azimuth=0.49)\n        surface!(ax, x, y, vals, color=vals, colormap=:viridis, colorrange=(-0.1, 0.3))\n        zlims!(ax, 0, 0.25)\n    end\n    return c\nend","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"<figure>\n    <img src='../figures/sibson_vs_sibson1.png', alt'Sibson and Sibson-1 Interpolation'><br>\n</figure>","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"The red points in (c) show the data used for interpolating. The results are pretty similar, although Sibson-1 is more bumpy in the zero region of the function. Sibson-1 is smooth wave on the rising front of the function.","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"Note that we are extrapolating in some parts of this function, where extrapolation refers to evaluating outside of the convex hull of the data sites. This convex hull is shown in white above. If we wanted to avoid extrapolating entirely, you can use project=false which replaces any extrapolated values with Inf.","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"sib_vals = itp(_x, _y, project=false)\nsib1_vals = itp(_x, _y; method=Sibson(1), project=false)\nfig = Figure(fontsize=36)\nplot_itp(fig, _x, _y, sib_vals, \"(a): Sibson\", 1, false, itp, x, y)\nplot_itp(fig, _x, _y, sib1_vals, \"(b): Sibson-1\", 2, false, itp, x, y)\nplot_itp(fig, _x, _y, f.(_x, _y), \"(c): Exact\", 3, true, itp, x, y)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"<figure>\n    <img src='../figures/sibson_vs_sibson1_project_false.png', alt'Sibson and Sibson-1 Interpolation without Extrapolation'><br>\n</figure>","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"To get a better comparison of the two interpolants, lets plot the errors at each point, including extrapolation.","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"sib_vals = itp(_x, _y)\nsib1_vals = itp(_x, _y; method=Sibson(1))\nsib_errs = @. 100abs(sib_vals - f(_x, _y))\nsib1_errs = @. 100abs(sib1_vals - f(_x, _y))\n\nfig = Figure(fontsize=36)\nplot_itp(fig, _x, _y, sib_errs, \"(a): Sibson\", 1, true, itp, x, y, false, 0:0.5:3)\nc = plot_itp(fig, _x, _y, sib1_errs, \"(b): Sibson-1\", 2, true, itp, x, y, false, 0:0.5:3)\nColorbar(fig[1, 3], c)\nresize_to_layout!(fig)\nfig","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"<figure>\n    <img src='../figures/sibson_vs_sibson1_errors.png', alt'Sibson and Sibson-1 Interpolation Errors'><br>\n</figure>","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"We see that the Sibson-1 interpolant has less error overall. To summarise these errors into a single scalar, we can use the relative root mean square error, defined by ","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"varepsilon_textrrmse(boldsymbol y hatboldsymbol y) = 100sqrtfracsum_i (y_i - hat y_i)^2sum_i hat y_i^2","category":"page"},{"location":"interpolation/","page":"Interpolation","title":"Interpolation","text":"julia> esib0 = 100sqrt(sum((sib_vals .- f.(_x, _y)).^2) / sum(sib_vals.^2))\n8.272516151708604\n\njulia> esib1 = 100sqrt(sum((sib1_vals .- f.(_x, _y)).^2) / sum(sib_vals.^2))\n6.974149853003652","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = NaturalNeighbours","category":"page"},{"location":"#NaturalNeighbours","page":"Home","title":"NaturalNeighbours","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for NaturalNeighbours.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is a package for working with natural neighbours of planar point sets, enabling scattered data (or spatial) interpolation via natural neighbour interpolation, as well as derivative generation. We use DelaunayTriangulation.jl to define the spatial information. Much of the work in this package is based on this great thesis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please see the sections in the sidebar for some more discussion. The relevant docstrings for this package are shown below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"interpolate\ndifferentiate \ngenerate_gradients\ngenerate_derivatives\nAbstractInterpolator\nAbstractDifferentiator\nSibson\nHiyoshi\nFarin\nLaplace\nTriangle\nNearest\nDirect\nIterative\nidentify_exterior_points","category":"page"},{"location":"#NaturalNeighbours.interpolate","page":"Home","title":"NaturalNeighbours.interpolate","text":"interpolate(tri::Triangulation, z; gradient=nothing, hessian=nothing, derivatives=false, kwargs...)\ninterpolate(points, z; gradient=nothing, hessian=nothing, derivatives=false, kwargs...)\ninterpolate(x::AbstractVector, y::AbstractVector, z; gradient=nothing, hessian=nothing, derivatives=false, kwargs...)\n\nConstruct an interpolant over the data z at the sites defined by the triangulation tri (or points, or (x, y)). See the Output  section for a description of how to use the interpolant itp.\n\nKeyword Arguments\n\ngradient=nothing: The gradients at the corresponding data sites of z. Will be generated if isnothing(gradient) and derivatives==true.\nhessian=nothing: The hessians at the corresponding data sites of z. Will be generated if isnothing(hessian) and derivatives==true.\nderivatives=false: Whether to generate derivatives at the data sites of z. See also generate_derivatives.\nkwargs...: Keyword arguments passed to generate_derivatives.\n\nOutput\n\nThe returned value is a NaturalNeighboursInterpolant struct. This struct is callable, with the following methods defined:\n\n(itp::NaturalNeighboursInterpolant)(x, y, id::Integer=1; parallel=false, method=Sibson(), project = true, kwargs...)\n(itp::NaturalNeighboursInterpolant)(vals::AbstractVector, x::AbstractVector, y::AbstractVector; parallel=true, method=Sibson(), project = true, kwargs...)\n(itp::NaturalNeighboursInterpolant)(x::AbstractVector, y::AbstractVector; parallel=true, method=Sibson(), project = true, kwargs...)\n\nThe first method is for scalars, with id referring to a thread id. \nThis method is an in-place method for vectors, storing itp(x[i], y[i]) into vals[i]. \nThis method is similar to (2), but vals is constructed and returned. \n\nIn each method, method defines the method used for evaluating the interpolant, which is some AbstractInterpolator. For the first  method, parallel is ignored, but for the latter two methods it defines whether to use multithreading or not for evaluating the interpolant at  all the points. The kwargs... argument is passed into add_point! from DelaunayTriangulation.jl, e.g. you could pass some rng. Lastly,  the project argument determines whether extrapolation is performed by projecting any exterior points onto the boundary of the convex hull  of the data sites and performing two-point interpolation, or to simply replace any extrapolated values with Inf.\n\nwarning: Warning\nUntil we implement ghost point extrapolation, behaviour near the convex hull of your data sites may in some cases be undesirable, despite the extrapolation method we describe above, even for points that are inside the convex hull. If you want to control this  behaviour so that you discard any points that are very close to the convex hull, see identify_exterior_points and the tol  keyword argument.\n\n\n\n\n\n","category":"function"},{"location":"#NaturalNeighbours.differentiate","page":"Home","title":"NaturalNeighbours.differentiate","text":"differentiate(itp::NaturalNeighboursInterpolant, order)\n\nDifferentiate a given interpolant itp up to degree order (1 or 2). The returned object is a  NaturalNeighboursDifferentiator struct, which is callable. \n\nFor calling the resulting struct, we define the following methods:\n\n(∂::NaturalNeighboursDifferentiator)(x, y, zᵢ, nc, id::Integer=1; parallel=false, method=default_diff_method(∂), kwargs...)\n(∂::NaturalNeighboursDifferentiator)(x, y, id::Integer=1; parallel=false, method=default_diff_method(∂), interpolant_method=Sibson(), rng=Random.default_rng(), project = true, kwargs...)\n(∂::NaturalNeighboursDifferentiator)(vals::AbstractVector, x::AbstractVector, y::AbstractVector; parallel=true, method=default_diff_method(∂), interpolant_method=Sibson(), kwargs...)\n(∂::NaturalNeighboursDifferentiator{I, O})(x::AbstractVector, y::AbstractVector; parallel=true, method=default_diff_method(∂), interpolant_method=Sibson(), kwargs...) where {I, O}\n\nThis method is useful if you already have an estimate for the function value, zᵢ, at the data site, (x, y), provided you also provide the NaturalCoordinates nc. id is the thread id.\nThis method is for scalars, with id referring to a thread id.\nThis method is an in-place method for vectors, storing ∂(x[i], y[i], 1) into vals[i].\nThis method is similar to (3), but vals is constructed and returned.\n\nThe available keyword arguments are:\n\nparallel=true: Whether to use multithreading. Ignored for the first two methods. \nmethod=default_diff_method(∂): Default method for evaluating the interpolant. default_diff_method(∂) returns Direct(). The method must be a AbstractDifferentiator.\ninterpolant_method=Sibson(): The method used for evaluating the interpolant to estimate zᵢ for the latter three methods. See AbstractInterpolator for the avaiable methods.\nrng=Random.default_rng(): The random number generator used for estimating zᵢ for the latter three methods, or for constructing the natural coordinates.\nproject=false: Whether to project any extrapolated points onto the boundary of the convex hull of the data sites and perform two-point interpolation, or to simply replace any extrapolated values with Inf, when evaluating the interpolant in the latter three methods.\nuse_cubic_terms=true: If estimating second order derivatives, whether to use cubic terms. Only relevant for method == Direct().\nalpha=0.1: If estimating second order derivatives, the weighting parameter used for estimating the second order derivatives. Only relevant for method == Iterative().\nuse_sibson_weight=true: Whether to weight the residuals in the associated least squares problems by the associated Sibson coordinates. Only relevant for method == Iterative() if order == 2.\n\nThe outputs are:\n\norder == 1: The scalar methods return a Tuple of the form (∂x, ∂y), while the vector methods return a vector of Tuples of the form (∂x, ∂y).\norder == 2: The scalar methods return a (∇, ℋ), where ∇ is a Tuple of the form (∂x, ∂y) and ℋ is a Tuple of the form (∂xx, ∂yy, ∂xy). The vector methods return a vector of (∇, ℋ)s.\n\nwarning: Warning\nUntil we implement ghost point extrapolation, behaviour near the convex hull of your data sites may in some cases be undesirable, despite the extrapolation method we describe above, even for points that are inside the convex hull. If you want to control this  behaviour so that you discard any points that are very close to the convex hull, see identify_exterior_points and the tol  keyword argument.\n\n\n\n\n\n","category":"function"},{"location":"#NaturalNeighbours.generate_gradients","page":"Home","title":"NaturalNeighbours.generate_gradients","text":"generate_gradients(\n    tri,\n    z,\n    derivative_caches=[DerivativeCache(tri) for _ in 1:Base.Threads.nthreads()],\n    neighbour_caches=[NaturalNeighboursCache(tri) for _ in 1:Base.Threads.nthreads()];\n    parallel=true\n)\n\nGenerate gradients at the data sites defined by the triangulation tri with associated function values tri.\n\nArguments\n\ntri: A Triangulation object.\nz: A vector of function values at the data sites.\nderivative_caches=[DerivativeCache(tri) for _ in 1:Base.Threads.nthreads()]: A vector of DerivativeCache objects, one for each thread.\nneighbour_caches=[NaturalNeighboursCache(tri) for _ in 1:Base.Threads.nthreads()]: A vector of NaturalNeighboursCache objects, one for each thread.\n\nKeyword Arguments\n\nparallel=true: Whether to use multithreading or not.\n\nOutput\n\n∇: A vector of gradients at the data sites. Each element is a Tuple defining the gradient entries.\n\n\n\n\n\n","category":"function"},{"location":"#NaturalNeighbours.generate_derivatives","page":"Home","title":"NaturalNeighbours.generate_derivatives","text":"generate_derivatives(\n    tri,\n    z,\n    derivative_caches=[DerivativeCache(tri) for _ in 1:Base.Threads.nthreads()],\n    neighbour_caches=[NaturalNeighboursCache(tri) for _ in 1:Base.Threads.nthreads()];\n    parallel=true,\n    method=Direct(),\n    use_cubic_terms=true,\n    alpha=0.1,\n    initial_gradients=dwrap(method) == Direct() ? nothing : generate_gradients(tri, z, derivative_caches, neighbour_caches; method=dwrap(method), parallel, rng)\n)\n\nGenerate derivatives at the data sites defined by the triangulation tri with associated function values tri.\n\nArguments\n\ntri: A Triangulation object.\nz: A vector of function values at the data sites.\nderivative_caches=[DerivativeCache(tri) for _ in 1:Base.Threads.nthreads()]: A vector of DerivativeCache objects, one for each thread.\nneighbour_caches=[NaturalNeighboursCache(tri) for _ in 1:Base.Threads.nthreads()]: A vector of NaturalNeighboursCache objects, one for each thread.\n\nKeyword Arguments\n\nparallel=true: Whether to use multithreading or not.\nmethod=Direct(): The method used for generating the derivatives. See AbstractDifferentiator.\nuse_cubic_terms=true: Whether to use cubic terms for estimating the second order derivatives. Only relevant for method == Direct().\nalpha=0.1: The weighting parameter used for estimating the second order derivatives. Only relevant for method == Iterative().\ninitial_gradients=dwrap(method) == Direct() ? nothing : generate_gradients(tri, z, derivative_caches, neighbour_caches; method=dwrap(method), parallel): The initial gradients used for estimating the second order derivatives. Only relevant for method == Iterative().\n\nOutput\n\n∇: A vector of gradients at the data sites. Each element is a Tuple defining the gradient entries.\nℋ: A vector of Hessians at the data sites. Each element is a Tuple defining the Hessian entries in the form (H[1, 1], H[2, 2], H[1, 2]) (H[2, 1] is the same as H[2, 2]).\n\n\n\n\n\n","category":"function"},{"location":"#NaturalNeighbours.AbstractInterpolator","page":"Home","title":"NaturalNeighbours.AbstractInterpolator","text":"abstract type AbstractInterpolator{D}\n\nAbstract type for defining the method used for evaluating an interpolant. D is, roughly, defined to be  the smoothness at the data sites (currently only relevant for Sibson). The available subtypes are:\n\nSibson(d): Interpolate via the Sibson interpolant, with C(d) continuity at the data sites. Only defined for D ∈ (0, 1). If D == 1, gradients must be provided.\nTriangle(d): Interpolate based on vertices of the triangle that the point resides in, with C(0) continuity at the data sites. D is ignored.\nNearest(d): Interpolate by returning the function value at the nearest data site. D doesn't mean much here (it could be D = ∞), and so it is ignored and replaced with 0.\nLaplace(d): Interpolate via the Laplace interpolant, with C(0) continuity at the data sites. D is ignored.\nFarin(d): Interpolate using the Farin interpolant, with C(1) continuity at the data sites. d is ignored.\nHiyoshi(d): Interpolate using the Hiyoshi interpolant, with C(d) continuity at the data sites. Currently, only defined for d == 2.\n\nOur implementation of Sibson(0)'s coordinates follows this article with some simple modifications.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.AbstractDifferentiator","page":"Home","title":"NaturalNeighbours.AbstractDifferentiator","text":"abstract type AbstractDifferentiator end\n\nAbstract type for defining the method used for differentiating an interpolant or generating derivatives at data sites. \n\nDirect(): Generate derivatives directly with one least squares problem.\nIterative(): Generate derivatives iteratively: Gradients are estimated first, and then both gradients and Hessians are estimated with the initial gradients used to refine the results.  \n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Sibson","page":"Home","title":"NaturalNeighbours.Sibson","text":"Sibson(d=0)\n\nInterpolate using Sibson's coordinates with C(d) continuity at the data sites.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Hiyoshi","page":"Home","title":"NaturalNeighbours.Hiyoshi","text":"Hiyoshi(d=2)\n\nInterpolate using Hiyoshi's C(2) interpolant. Hiyoshi's interpolant C(0) is not yet implemented,  but we do not make any conversions to C(2) like in e.g. Farin(), e.g. Farin() gets  converted to Farin(1) but, to support possible later versions, Hiyoshi() does not get  converted to Hiyoshi(2).\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Farin","page":"Home","title":"NaturalNeighbours.Farin","text":"Farin()\n\nInterpolate using Farin's C(1) interpolant.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Laplace","page":"Home","title":"NaturalNeighbours.Laplace","text":"Laplace()\n\nInterpolate using Laplace's coordinates.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Triangle","page":"Home","title":"NaturalNeighbours.Triangle","text":"Triangle()\n\nInterpolate using a piecewise linear interpolant over the underlying triangulation.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Nearest","page":"Home","title":"NaturalNeighbours.Nearest","text":"Nearest()\n\nInterpolate by taking the function value at the nearest data site.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Direct","page":"Home","title":"NaturalNeighbours.Direct","text":"Direct()\n\nGenerate derivatives directly with one least squares problem.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.Iterative","page":"Home","title":"NaturalNeighbours.Iterative","text":"Iterative()\n\nGenerate derivatives iteratively: Gradients are estimated first, and then both gradients and Hessians are estimated with the initial gradients used to refine the results.\n\n\n\n\n\n","category":"type"},{"location":"#NaturalNeighbours.identify_exterior_points","page":"Home","title":"NaturalNeighbours.identify_exterior_points","text":"identify_exterior_points(x, y, points, boundary_nodes; tol = 0.0)\n\nGiven a polygon described by (points, boundary_nodes), matching the  specification of polygons in DelaunayTriangulation.jl (see here), returns a vector of indices of the points defined by (x, y) that are outside of the polygon.\n\nUse tol to specify a tolerance for the distance to the polygon.\n\n\n\n\n\nidentify_exterior_points(x, y, itp::NaturalNeighboursInterpolant; tol = 0.0)\n\nReturns the indices of the points defined by the vectors (x, y) that are  outside of the underlying triangulation to the interpolant itp.\n\nUse tol to specify a tolerance for the distance to the triangulation.\n\n\n\n\n\n","category":"function"}]
}
